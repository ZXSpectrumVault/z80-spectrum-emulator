startup segment para public

slowproc equ 68                ;see get_line and get_line_86.  HCR tinkering

movsd macro
        db 066
        movsw
#em

stosd macro
        db 066
        stosw
#em

lodsd macro
        db 066
        lodsw
#em

cmpsd macro
        db 066
        cmpsw
#em

        testsi2   equ 014b7             ; testsi address ***** HMc *****
        Ldiradr   equ 020b7             ; ldir address ***** HMc *****
        Lddradr   equ 022b7             ; lddr address ***** HMc *****


install_all:
        mov al,cs:_usercoloremu
        and al,1
        neg al
        test word cs:_nohcrmem  ;No hcr memory buffers?
        if nz xor al,al
        cmp byte cs:gmod,5           ;vga?
        if nz xor al,al         ;If not then no hi res color emulation
        test byte cs:modflg     ;real mode?
        if nz xor al,al         ;no hcr in real mode either
        test byte cs:_vocplay
        if nz xor al,al         ;and neither while playing voc files
        test byte cs:_outlog
        if nz xor al,al         ;and neither while logging outs
        mov cs:coloremu,al
        test al
        je rri_nohcr
        mov byte cs:linecounter,1     ;In hrc emul mode, reset hcr vars
        mov es,cs:vgahcrborbuf
        mov al,cs:borclr
        mov es:[2],al
        mov es:w[0],0
        mov byte cs:bornochange,-3
        mov word cs:vgahcrborbufptr,3
        cmp byte cs:viertel,0
        jne rri_nohcr
        mov word cs:dispaddrpointer,offset vga_coloremu_table+4*95
        mov word cs:vgahcrbufpointer,164+40*95
rri_nohcr:
        mov al,cs:coloremu
        or al,cs:winkey
        or al,cs:_vocplay
        or al,cs:_outlog
        mov cs:countt,al

        mov word cs:tquarter,17472
        mov word cs:tconst,224
        mov word cs:tconstlabel1,224
        mov word cs:tconstlabel2,224
        mov word cs:tconstlabel4,17472
        push es
        mov ax,seg emulate
        mov es,ax
        mov word es:tconstlabel3,224
        mov byte es:hcr_tinker1,34
        mov byte es:hcr_tinker2,34
        mov byte es:hcr_tinker3,34
        mov byte es:hcr_tinker4,34
        pop es

; T=0 == upper border part; viertel=0 == first screen line
; T0 = offset for block; tstates0 = length of 1st block/line (border/screen)
; viertel = 3 : T = 0 Tstates           ;tstates0 = 14336 ;l0 = (256)-1
;           0 : T = 64*224 =    14336 T ;tstates0 =   112            -96
;           1 : T = 159.5*224 = 35728 T ;tstates0 =   224            -97
;           2 : T = 256.5*224 = 57456 T ;tstates0 = 12432            -1
;hcr_border0: (ed.8): T = -224linecounter - tstates
;T = 224l0 - 224linecounter - tstates + tstates0 + T0
;offset = 224l0 + T0 + tstates0
;

        mov cs:tconst0,224*1 + 0 + 14336
        mov cs:tconst1,224*96 + 14336 + 112
        mov cs:tconst2,224*97 + 35728 + 224
        mov cs:tconst3,224*1 + 57456 + 12432

        mov cs:tconst4,64*224-224       ;the -224 is to compensate for extra add
        mov cs:tconst5,55*224+112-224   ;same here
        mov cs:tconst6,60*224-4*4       ;time of upper left border byte displayed
        cmp byte cs:rommod,4            ;128?
        jb rri_no128

        mov word cs:tquarter,17727
        mov word cs:tconst,228
        mov word cs:tconstlabel1,228
        mov word cs:tconstlabel2,228
        mov word cs:tconstlabel4,17727
        push es
        mov ax,seg emulate
        mov es,ax
        mov word es:tconstlabel3,228
        mov byte es:hcr_tinker1,45
        mov byte es:hcr_tinker2,45
        mov byte es:hcr_tinker3,45
        mov byte es:hcr_tinker4,45
        pop es

        mov cs:tconst0,228*1 + 0 + 14364        ;14364=63*228
        mov cs:tconst1,228*96 + 14364 + 114
        mov cs:tconst2,228*97 + 36138 + 228
        mov cs:tconst3,228*1 + 58254 + 12654

        mov cs:tconst4,63*228-228
        mov cs:tconst5,55*228+114-228
        mov cs:tconst6,59*228-4*4
rri_no128:
        call install_blaster
        call speed_convert              ;maybe hi color emu mode changed?
        CALL HOESNEL
        CALL RREG_INST
        CALL LDIR_INST
        CALL SILENCE_INST
        ret



;Code for hi res color emulation on <=286 cpu's


ihc_quarter_86:
        mov cs:b[linecounter],1         ;default value
        mov bl,cs:viertel
        dec bl
        je ihc_finish_86                ;if was 1, then will be 2, finished grabbing
        dec bl
        je ihc_upborder_86              ;if was 2 do upper border part
        dec bl
        je ihc_videmul_86               ;if was 3 do upper screen part
        mov cs:b[linecounter],97        ;half a screen
        call get_line_86                ;get final line of prev. half too
        jmp bare_inter_handler
ihc_upborder_86:
        mov bx,cs:tconst4
        add cs:w[_tstates],bx           ;Next breakpoint at 64 lines after interr.
        mov byte cs:vgahcrnodata,0      ;Signal: data in hcr buffer (will be) ok
        call ihc_border_86
        jmp bare_inter_handler          ; (-244 to compensate for add in ihc itself)
ihc_videmul_86:
        mov bx,cs:tconst
        shr bx,1
        sub bx,cs:tconst
        add cs:w[_tstates],bx           ;Start vid. emul. halfway line 0
        mov word cs:dispaddrpointer,offset vga_coloremu_table
        mov word cs:vgahcrbufpointer,164        ;(4*40*2+8)/2
        mov cs:b[linecounter],96        ;half a screen
        jmp bare_inter_handler


;
;The following routine is called _very_ often in hi color emu mode
;
inter_handler_coloremu_86:
        cld
        add cs:w[_tstates],224          ;reset T states counter.  Don't bother
tconstlabel1 equ $-2                    ; about tstatehi.
        dec cs:b[linecounter]           ;Decrease line counter. If it was 1
        je ihc_quarter_86               ; then a '200 Hz' interrupt has to be
                                        ; generated, and the video emulation
                                        ; has to be started/stopped.
        call get_line_86
        jmp far emulate_0


ihc_finish_86:
        mov bx,cs:tconst5
        add cs:w[_tstates],bx           ;Still 55.5 lines to do
        push ax
        push cx
        push dx
        push bp
        push si
        push di
        push ds
        push es
        mov ax,cs:[vgahcrbuf]
        mov es,ax                       ;ds->specseg
        cmp byte cs:vgahcrnodata,0ff
        if ne jmp ihcf_ok_86
        test byte cs:hstate,8           ;Is the screen at page 7 now?
        mov si,04000
        je ihcf_si_86                   ;Nope, page 5 is (fixed at 4000)
        cmp byte cs:[ramstate+3],10     ;Page 7 in bank 3?
        mov si,0c000
        je ihcf_si_86
        mov si,04000
        test word cs:emshandle          ;Hope we're not using EMS
        je ihcf_second_in_ram_86
        mov ax,010a
        call swap_mem
        jmp short ihcf_si_86
ihcf_second_in_ram_86:
        mov ax,cs:romseg
        add ax,9*0400
        push ax
        pop ds                  ;ds:04000 = page 7, int. page 10
ihcf_si_86:
        mov di,164
        mov bl,192
ihcf_ved_0_86:
        mov cx,32/2
        rep movsw
        add si,256-32
        test si,2048-256
        jne ihcf_ved_00_86
        add si,32-2048
        test si,255
        jne ihcf_ved_00_86
        add si,2048-256
ihcf_ved_00_86:
        add di,8
        dec bl
        jne ihcf_ved_0_86
        mov bl,24
        mov di,8192+164
ihcf_ved_2_86:
        mov bh,8
ihcf_ved_3_86:
        mov cx,32/2
        rep movsw
        add di,8
        sub si,32
        dec bh
        jne ihcf_ved_3_86
        add si,32
        dec bl
        jne ihcf_ved_2_86
        mov ax,0108
        cmp byte cs:[ramstate+1],10
        if e call swap_mem
ihcf_ok_86:
        mov ax,es
        mov ds,ax
        mov bp,ax
        test byte cs:fflag
        je ihc_f_noflash_86
        mov byte cs:fflag,0
        mov si,164+8192
        mov cx,(192*40)/2 - 4
        mov dx,08080
ihc_zero_flash_86:
        lodsw
        and ax,dx
        not ax
        and [si+16384-2],ax
        loop ihc_zero_flash_86
ihc_f_noflash_86:
        mov dx,0b800
        mov di,16384+164
        mov si,164
        mov cx,(192*40)/2 - 4           ;192 lines of 40 bytes, minus 2x2 words
        cmp al,al
ihc_screen_86:
        repz
        cmpsw
        jz ihc_attr_86
        mov ax,[si-2]
        mov [di-2],ax
        mov ds,dx
        add si,si
        mov b[si-4],al
        mov b[si-2],ah
        shr si,1
        mov ds,bp
        cmp al,al
        jmp ihc_screen_86
ihc_attr_86:
        mov bx,offset vga_workspace
        add bx,cs:fstate
        mov cx,(192*40)/2 - 4           ;192 lines of 40 bytes, minus 2x2 words
        mov si,164+8192
        mov di,164+8192+16384
        cmp al,al
ihc_atrloop_86:
        repz
        cmpsw
        jz ihc_end_86
        mov ax,[si-2]
        mov [di-2],ax
        add si,si
        cs:xlatb
        mov ds,dx
        mov b[si-04003],al
        mov al,ah
        cs:xlatb
        mov b[si-04001],al
        mov ds,bp
        shr si,1
        cmp al,al
        jmp ihc_atrloop_86
ihc_end_86:
        pop es
        pop ds
        pop di
        pop si
        pop bp
        pop dx
        pop cx
        pop ax
        jmp bare_inter_handler


get_line_86:
        push ax
        push si
        push di
        push es
        cmp di,32768
        jae get_line_notinlowram_86
        cmp di,16384
        jb get_line_notinlowram_86
        sub cs:w[_tstates],slowproc     ;to account for slower processing (tricky)
get_line_notinlowram_86:
        mov si,cs:[dispaddrpointer]
        cs:lodsw                        ;get attr offset
        mov bx,ax
        cs:lodsw                        ;get screen address
        mov cs:[dispaddrpointer],si
        les di,cs:[vgahcrbufpointer]    ;get pointer into hcr buffer
        add ax,cs:vgahcrscroffset       ;maybe screen is in bank 3
        jc get_line_err_86
        mov si,ax
move8 macro
        movsw
        movsw
        movsw
        movsw
#em
        move8
        move8
        move8
        move8
        add di,8192-32                  ;go to attr part
        add si,bx                       ;go to attr area on spec. screen
        move8
        move8
        move8
        move8
        add di,8-8192                   ;go to next line in hcr buffer
get_line_end_86:
        mov cs:[vgahcrbufpointer],di
        pop es
        pop di
        pop si
        pop ax
        ret
get_line_err_86:
        mov byte cs:vgahcrnodata,0ff
        add di,40
        jmp get_line_end_86


ihc_border_86:
        cmp byte cs:bornochange,0ff
        je ret
        inc byte cs:bornochange
        push ax
        push cx
        push dx
        push si
        push di
        push ds
        push es
        les di,cs:vgahcrborbufptr
        mov al,es:[di-1]
        mov cs:borclr,al
        mov ax,-1
        stosw
        mov ax,es
        mov ds,ax
        xor si,si
        lodsw
        mov bx,ax                       ;bx = next OUT time (0 at first)
        mov ax,0b800
        mov es,ax
        xor di,di
        mov dx,cs:tconst6               ;start of first border line displayed
        call ihc_border4_86             ;display first 4 lines
        call ihc_border4_86
        call ihc_border4_86
        call ihc_border4_86
        mov cx,192
ihc_borderloop_86:
        add dx,cs:tconst                ;next line
        cmp bx,dx                       ;is border fixed at this line?
        jb ihc_border3_86               ;if not jump
        stosw                           ;2 bytes = 1 attr
        stosw
        stosw
        stosw
        add di,64
        stosw
        stosw
        stosw
        stosw
loopihc_borderloop_86:
        loop ihc_borderloop_86
        call ihc_border4_86                ;display final 4 lines
        call ihc_border4_86
        call ihc_border4_86
        call ihc_border4_86
        mov al,cs:newbor
        mov b[2],al
        mov w[0],0                      ;Store OUT at time 0
        mov word cs:vgahcrborbufptr,3
        pop es
        pop ds
        pop di
        pop si
        pop dx
        pop cx
        pop ax
        ret

ihc_border3_86:
        sub dx,cs:tconst                ;restore actual value of T
        push cx
        mov cx,0404                     ;4 bytes
ihc_borderleft_86:
        cmp bx,dx                       ;has there been an OUT before T?
        jae ihc_noborchange_86          ;If not jump
ihc_bl_next_86:
        inc si                          ;skip color of last OUT
        lodsw                           ;new OUT time
        cmp ax,dx
        jb ihc_bl_next_86
        mov bx,ax
        mov ah,[si-3]
        and ax,0700
        shl ax,cl
ihc_noborchange_86:
        stosw                           ;store byte
        add dx,4
        dec ch
        jne ihc_borderleft_86
        add dx,32*4
        add di,64
        mov cx,0404                     ;4 bytes at the right
ihc_borderright_86:
        cmp bx,dx                       ;has there been an OUT before T?
        jae ihc_noborchanger_86         ;If not jump
ihc_br_next_86:
        inc si                          ;skip color
        lodsw
        cmp ax,dx
        jb ihc_br_next_86
        mov bx,ax
        mov ah,[si-3]
        and ax,0700
        shl ax,cl
ihc_noborchanger_86:
        stosw                           ;store byte
        add dx,4
        dec ch
        jne ihc_borderright_86
        sub dx,128+32                   ;go back to time of leftmost borderbyte
        add dx,cs:tconst                ;next line
        pop cx
        jmp loopihc_borderloop_86

ihc_border4_86:                         ;Display a whole line
        add dx,cs:tconst                ;next line
        cmp bx,dx                       ;is border fixed at this line?
        jb ihc_border43_86              ;if not jump
        mov cx,40
        rep stosw
        ret
ihc_border43_86:
        sub dx,cs:tconst                ;restore actual value of T
        mov cx,02804                    ;40 bytes
ihc_border44_86:
        cmp bx,dx                       ;has there been an OUT before T?
        jae ihc_noborchange4_86         ;If not jump
ihc_bl_next4_86:
        inc si                          ;skip color
        lodsw
        cmp ax,dx
        jb ihc_bl_next4_86
        mov bx,ax
        mov ah,[si-3]
        and ax,0700
        shl ax,cl
ihc_noborchange4_86:
        stosw                           ;store byte
        add dx,4
        dec ch
        jne ihc_border44_86
        sub dx,128+32                   ;(40*4)
        add dx,cs:tconst                ;horizontal retrace
        ret




;Code for hi res color emulation on >= 386 cpu's

ihc_quarter:
        mov cs:b[linecounter],1         ;default value
        mov bl,cs:viertel
        dec bl
        je ihc_finish                   ;if was 1, then will be 2, finished grabbing
        dec bl
        je ihc_upborder                 ;if was 2 do upper border part
        dec bl
        je ihc_videmul                  ;if was 3 do upper screen part
        mov cs:b[linecounter],97        ;half a screen
        call get_line                   ;get final line of prev. half too
        jmp bare_inter_handler
ihc_upborder:
        mov bx,cs:tconst4
        add cs:w[_tstates],bx           ;Next breakpoint at 64 lines after interr.
        mov byte cs:vgahcrnodata,0      ;Signal: data in hcr buffer (will be) ok
        call ihc_border
        jmp bare_inter_handler          ; (-244 to compensate for add in ihc itself)
ihc_videmul:
        mov bx,cs:tconst
        shr bx,1
        sub bx,cs:tconst
        add cs:w[_tstates],bx           ;Start vid. emul. halfway line 0
        mov word cs:dispaddrpointer,offset vga_coloremu_table
        mov word cs:vgahcrbufpointer,164        ;(4*40*2+8)/2
        mov cs:b[linecounter],96        ;half a screen
        jmp bare_inter_handler


;
;The following routine is called _very_ often in hi color emu mode
;
inter_handler_coloremu:
        cld
        add cs:w[_tstates],224          ;reset T states counter.  Don't bother
                                        ; about tstatehi.
tconstlabel2 equ $-2
        dec cs:b[linecounter]           ;Decrease line counter. If it was 1
        je ihc_quarter                  ; then a '200 Hz' interrupt has to be
                                        ; generated, and the video emulation
                                        ; has to be started/stopped.
        call get_line
        jmp far emulate_0


ihc_finish:
        mov bx,cs:tconst5
        add cs:w[_tstates],bx            ;Still 55.5 lines to do
        push ax
        push cx
        push si
        push di
        push ds
        push es
        mov ax,cs:[vgahcrbuf]
        mov es,ax
        cmp byte cs:vgahcrnodata,0ff
        if ne jmp ihcf_ok
        test byte cs:hstate,8           ;Is the screen at page 7 now?
        mov si,04000
        je ihcf_si                      ;Nope, page 5 is (fixed at 4000)
        cmp byte cs:[ramstate+3],10     ;Page 7 in bank 3?
        mov si,0c000
        je ihcf_si
        mov si,04000
        test word cs:emshandle          ;Hope we're not using EMS
        je ihcf_second_in_ram
        mov ax,010a
        call swap_mem
        jmp short ihcf_si
ihcf_second_in_ram:
        mov ax,cs:romseg
        add ax,9*0400
        push ax
        pop ds                  ;ds:04000 = page 7, int. page 10
ihcf_si:
        mov di,164
        mov bl,192
ihcf_ved_0:
        mov cx,32/4
        rep
        db 066
        movsw
        add si,256-32
        test si,2048-256
        jne ihcf_ved_00
        add si,32-2048
        test si,255
        jne ihcf_ved_00
        add si,2048-256
ihcf_ved_00:
        add di,8
        dec bl
        jne ihcf_ved_0
        mov bl,24
        mov di,8192+164
ihcf_ved_2:
        mov bh,8
ihcf_ved_3:
        mov cx,32/4
        rep
        db 066
        movsw
        add di,8
        sub si,32
        dec bh
        jne ihcf_ved_3
        add si,32
        dec bl
        jne ihcf_ved_2
        mov ax,0108
        cmp byte cs:[ramstate+1],10
        if e call swap_mem
ihcf_ok:
        mov ax,es
        mov ds,ax
        test byte cs:fflag
        je ihc_f_noflash
        mov byte cs:fflag,0
        mov si,164+8192
        mov cx,(192*40)/4 - 2
        db 066
        mov bx,08080
        dw 08080
ihc_zero_flash:
        lodsd
        db 066
        and ax,bx
        db 066
        not ax
        db 066
        and [si+16384-4],ax
        loop ihc_zero_flash
ihc_f_noflash:
        mov ax,0b800
        db 08e,0e0                      ;mov fs,ax
        mov di,16384+164
        mov si,164
        mov cx,(192*40)/4 - 2           ;192 lines of 40 bytes, minus 1x2 dwords
        cmp al,al
ihc_screen:
        repz
        cmpsd
        jz ihc_attr
        sub si,4
        sub di,4
        mov bx,si
        lodsd
        stosd
        db 064                          ;fs:
        mov b[si+bx-4],al
        db 064
        mov b[si+bx-2],ah
        db 066
        shr ax,16
        db 064
        mov b[si+bx],al
        db 064
        mov b[si+bx+2],ah
        cmp al,al
        jmp ihc_screen
ihc_attr:
        mov bx,offset vga_workspace
        add bx,cs:fstate
        mov cx,(192*40)/4 - 2           ;192 lines of 40 bytes, minus 2x1 dwords
        mov si,164+8192
        mov di,164+8192+16384
        cmp al,al
ihc_atrloop:
        repz
        cmpsd
        jz ihc_end
        sub si,4
        sub di,4
        lodsd
        stosd
        add si,si
        cs:xlatb
        db 064                          ;fs:
        mov b[si-04007],al
        db 066
        shr ax,8
        cs:xlatb
        db 064
        mov b[si-04005],al
        db 066
        shr ax,8
        cs:xlatb
        db 064
        mov b[si-04003],al
        mov al,ah
        cs:xlatb
        db 064
        mov b[si-04001],al
        shr si,1
        cmp al,al
        jmp ihc_atrloop
ihc_end:
        pop es
        pop ds
        pop di
        pop si
        pop cx
        pop ax
        jmp bare_inter_handler


ihc_border:
        cmp byte cs:bornochange,0ff
        je ret
        inc byte cs:bornochange
        push ax
        push cx
        push dx
        push si
        push di
        push ds
        push es
        les di,cs:vgahcrborbufptr
        mov al,es:[di-1]
        mov cs:borclr,al
        mov ax,-1
        stosw
        mov ax,es
        mov ds,ax
        xor si,si
        lodsw
        mov bx,ax                       ;bx = next OUT time (0 at first)
        mov ax,0b800
        mov es,ax
        xor di,di
        mov dx,cs:tconst6               ;start of first border line displayed
        call ihc_border4                ;display first 4 lines
        call ihc_border4
        call ihc_border4
        call ihc_border4
        mov cx,192
ihc_borderloop:
        add dx,cs:tconst                ;next line
        cmp bx,dx                       ;is border fixed at this line?
        jb ihc_border3                  ;if not jump
        stosd                           ;4 bytes = 2 attrs
        stosd
        add di,64
        stosd
        stosd
loopihc_borderloop:
        loop ihc_borderloop
        call ihc_border4                ;display final 4 lines
        call ihc_border4
        call ihc_border4
        call ihc_border4
        mov al,cs:newbor
        mov b[2],al
        mov w[0],0                      ;Store OUT at time 0
        mov word cs:vgahcrborbufptr,3
        pop es
        pop ds
        pop di
        pop si
        pop dx
        pop cx
        pop ax
        ret

ihc_border3:
        sub dx,cs:tconst                ;restore actual value of T
        push cx
        mov cx,4                        ;4 bytes
ihc_borderleft:
        cmp bx,dx                       ;has there been an OUT before T?
        jae ihc_noborchange             ;If not jump
ihc_bl_next:
        inc si                          ;skip color of last OUT
        lodsw                           ;new OUT time
        cmp ax,dx
        jb ihc_bl_next
        mov bx,ax
        mov ah,[si-3]
        and ax,0700
        shl ax,4
ihc_noborchange:
        stosw                           ;store byte
        add dx,4
        loop ihc_borderleft
        add dx,32*4
        add di,64
        mov cx,4                        ;4 bytes at the right
ihc_borderright:
        cmp bx,dx                       ;has there been an OUT before T?
        jae ihc_noborchanger            ;If not jump
ihc_br_next:
        inc si                          ;skip color
        lodsw
        cmp ax,dx
        jb ihc_br_next
        mov bx,ax
        mov ah,[si-3]
        and ax,0700
        shl ax,4
ihc_noborchanger:
        stosw                           ;store byte
        add dx,4
        loop ihc_borderright
        sub dx,128+32                   ;horizontal retrace
        add dx,cs:tconst
        db 066
        xor cx,cx
        mov cx,ax
        db 066
        shl ax,16
        db 066
        or ax,cx                        ;make 32 bit color value
        pop cx
        jmp loopihc_borderloop

ihc_border4:                            ;Display a whole line
        add dx,cs:tconst                ;next line
        cmp bx,dx                       ;is border fixed at this line?
        jb ihc_border43                 ;if not jump
        mov cx,20
        rep
        stosd
        ret
ihc_border43:
        sub dx,cs:tconst                ;restore actual value of T
        mov cx,40                       ;40 bytes
ihc_border44:
        cmp bx,dx                       ;has there been an OUT before T?
        jae ihc_noborchange4            ;If not jump
ihc_bl_next4:
        inc si                          ;skip color
        lodsw
        cmp ax,dx
        jb ihc_bl_next4
        mov bx,ax
        mov ah,[si-3]
        and ax,0700
        shl ax,4
ihc_noborchange4:
        stosw                           ;store byte
        add dx,4
        loop ihc_border44
        sub dx,128+32                   ;horizontal retrace
        add dx,cs:tconst
        db 066
        xor cx,cx
        mov cx,ax
        db 066
        shl ax,16
        db 066
        or ax,cx                        ;make 32 bit color value
        ret





get_line:
        push ax
        push si
        push di
        push es
        cmp di,32768
        jae get_line_notinlowram
        cmp di,16384
        jb get_line_notinlowram
        sub cs:w[_tstates],slowproc     ;to account for slower processing
get_line_notinlowram:
        mov si,cs:[dispaddrpointer]
        cs:lodsw                        ;get attr offset
        mov bx,ax
        cs:lodsw                        ;get screen address
        mov cs:[dispaddrpointer],si
        les di,cs:[vgahcrbufpointer]    ;get pointer into hcr buffer
        add ax,cs:vgahcrscroffset       ;maybe screen is in bank 3
        jc get_line_err
        mov si,ax
        movsd
        movsd
        movsd
        movsd
        movsd
        movsd
        movsd
        movsd
        add di,8192-32                  ;go to attr part
        add si,bx                       ;go to attr area on spec. screen
        movsd
        movsd
        movsd
        movsd
        movsd
        movsd
        movsd
        movsd
        add di,8-8192                   ;go to next line in hcr buffer
get_line_end:
        mov cs:[vgahcrbufpointer],di
        pop es
        pop di
        pop si
        pop ax
        ret
get_line_err:
        mov byte cs:vgahcrnodata,0ff
        add di,40
        jmp get_line_end


;
;The following routine is called from the actual emulator code, when in
;Windows compatibility mode or playing a voc file. The code calling it is
;assembled by rreg_makeblock.
;
inter_handler:
        add cs:w[_tstates],17472         ;reset T state counter
tconstlabel4 equ $-2
        inc cs:w[_tstatehi]
        push cx
        push bx
        mov cx,0ffff                    ;signal '1/200s tick'
        mov bx,cs:tquarter              ;17472 or 17727 T states
        test byte cs:tracing
        if z call outlog_save5bytes     ;save to outlog file if logging outs
        pop bx                          ; but do not when tracing.
        pop cx
bare_inter_handler:
        push ax
        push bx
        push cx
        push dx
        push bp
        mov byte cs:lastvocbit,0        ;Signal: Bit invalid (counter wrapped)
        jmp short win_comp_entry

endint1_x: jmp endint1

TIMER:  STI
        PUSH AX
        MOV AL,020
        OUT 020,AL
        test byte cs:countt             ;When playing a VOC file or emulating
        jnz endint1_x                   ; hires colours, use T state counter
        MOV AL,CS:INTTEL                ; instead of timer interrupt.
        INC AL
        CMP AL,CS:MAXTEL
        JB NOTMAX
        xor al,al
NOTMAX: MOV CS:INTTEL,AL
        jnz endint1_x
        cmp byte cs:doublec,0
        jnz endint1_x                   ;NOG NIET TIJD VOOR EEN IRPT
        PUSH BX                         ; (see below) (called at 200Hz)
        PUSH CX
        PUSH DX
        PUSH BP
        MOV BP,SP
        CMP W[BP+12],SEG EMULATE        ;KWAM INTRPT VAN SPEC.EMUL?
        IF NZ JMP ENDINT
win_comp_entry:                         ;entry point in T state counting mode
        inc word cs:_count200hz
        cmp byte cs:rommod,4            ; (see below) (called at 200Hz)
        jb timer_noenv                  ;If not 128 mode, don't bother about Adlib
        cmp byte cs:adlib,0ff
        je timer_env
        cmp byte cs:intsnd,0ff
        jne timer_noenv
timer_env:
        cmp byte cs:silence,0
        jne timer_noenv
        mov ax,cs:envaddlo
        add cs:envnumlo,ax
        mov ax,0
        adc ax,cs:envaddhi
        test ax,ax
        jz timer_noenv
        call update_channels            ;ZIE MDRV.8
timer_noenv:
        test byte cs:countt             ;counting T states?
        if e mov cs:_tstates,224        ;If not, make sure _tstates is big
        inc byte cs:mdrv_counter        ; (for PUSH cc hacks, see emul.8)
        cmp byte cs:mdrv_counter,5
        jnz no_mdrv_action
        mov byte cs:mdrv_counter,0
        call mdrv_writegap
no_mdrv_action:
        test cs:byte modflg,2           ;Toets ingedrukt in real mode?
        if nz jmp do_modchg
        cmp cs:byte spctel,0
        jz tim_nospace
        dec cs:byte spctel
        if z or byte cs:[offset in_tab+7],1         ;Laat SPACE los
tim_nospace:
        cmp byte cs:readtypeahead,0ff
        je tim_readtypeahead
;        cmp byte cs:winkey,0            ;Windows compatibility mode?
;        if z jmp tim_normal
        jmp tim_normal                  ;Never use INT 10 to read keys (v3.04)
tim_readtypeahead:
        mov ah,2                        ;get shift state
        int 016
        mov ah,al
        shr ah,1
        or al,ah
        and al,5                        ;or left & right shift, and ctrl & alt.
        cmp cs:wkbd_shift,al
        jz tim_noshiftchange
        mov cs:wkbd_shift,al
        shr al,1
        push ax
        mov al,02a*2                    ;left shift
        cmc
        rcr al,1
        call emulate_kbd_interrupt
        pop ax
        shr al,1
        shr al,1
        mov al,01d*2                    ;ctrl
        cmc
        rcr al,1
        call emulate_kbd_interrupt
tim_noshiftchange:
        mov ah,1
        int 016
        jz tim_nokeys
        xor ah,ah
        int 016
        test al                         ;extended key code?
        jne tim_normalkey
        cmp ah,078
        if ae sub ah,078-02             ;Digits 1-9,0 etc to scancode
        cmp ah,068
        if ae sub ah,068-03b            ;Alt Fx to scancode Fx
        cmp ah,05e
        if ae sub ah,05e-03b            ;Ctrl Fx
        cmp ah,054
        if ae sub ah,054-03b            ;Shft Fx
tim_normalkey:
        mov al,ah
        xchg ah,cs:wkbd_lastscan
        mov byte cs:wkbd_count,5        ;auto repeat: hold down appr. 25 ms
        cmp al,ah
        jz tim_ok
        mov byte cs:wkbd_count,30       ;first key depress: hold down 150 ms
        test ah
        jz tim_ok
        push ax
        mov al,ah
        or al,080
        call emulate_kbd_interrupt      ;release previous key
        pop ax
tim_ok:
        call emulate_kbd_interrupt
        jmp tim_noshiftchange
tim_nokeys:
        cmp byte cs:wkbd_count,1
        jnz tim_normal
        mov byte cs:wkbd_count,0
        xor al,al
        xchg al,cs:wkbd_lastscan
        test al
        jz tim_normal
        or al,080
        call emulate_kbd_interrupt      ;release key after approx 250 ms
tim_normal:
        mov al,cs:viertel
        inc al
        and al,3
        mov cs:viertel,al
        inc al                          ;because irupt should be at 2->3
        and al,3
        test byte cs:double
        jne tim_doublespeed             ;jump on double irpt speed
        MOV AH,0FF
        CMP AL,3
        IF Z INC AH
        TEST AL
        IF Z INC AH
        MOV CS:RFSHFLG,AH               ;in 0ff geeft 0ff in frame 0 en 3
        jz set_irupt                    ;if interrupt then no screen update needed
        cmp al,cs:syncmod               ;update screen?
        jne jmphandleirupt
        cmp cs:byte modflg,080
        je upd_vid_partial
        cmp cs:byte modflg,0
        jnz handle_irupt
upd_vid_partial:
        call flashcount
        test byte cs:coloremu,0ff       ;hi color res emulation?
        if e CALL VIDEO_UPDATE          ;only call vid_upd if not
        call get_zxprintstatus
        call joystick_update
        CALL UPDATE_DTR
        CALL UPDATE_BUFSTATUS
        jmp short handle_irupt          ;jump forward to handle reset/nmi/c
set_irupt:
        test byte cs:nmi                ;0ff = nmi, 080 = reset, 0 = nothing
        jnz handle_irupt
        test byte cs:iff,0ff
        if nz mov byte cs:nmi,0fe       ;signal: interrupt
jmphandleirupt:
        jmp short handle_irupt
tim_doublespeed:
        MOV BYTE CS:RFSHFLG,0FF
        cmp al,0
        jz set_irupt                    ;timeframe 0: alleen interrupt
        cmp al,2
        jnz handle_irupt                ;timeframe 2: irpt en video
        cmp cs:byte modflg,0            ;low bits: 1 or 2, no vid update
        jz nrm_vid_upd                  ; unless bit 7=1
        test cs:byte modflg,080
        je set_irupt
nrm_vid_upd:
        call flashcount
        test byte cs:coloremu,0ff       ;hi color res emulation?
        if e CALL VIDEO_UPDATE          ;only call vid_upd if not
        call get_zxprintstatus
        call joystick_update
        CALL UPDATE_DTR
        CALL UPDATE_BUFSTATUS
        jmp set_irupt

do_modchg:
        mov byte cs:c_action_code,0f4
        mov byte cs:c_active,0ff
handle_irupt:
        test byte cs:c_active
        jne find_end_instr
        cmp byte cs:nmi,0               ;no nmi/inter/reset ?
        jne find_end_instr
        jmp endint

find_end_ctt:
        test byte cs:nmi,0ff            ;nmi/inter/reset
        if z jmp end_of_z80_instr       ;if not, do not step over HALT
        cmp b[di],118                   ;step over possible HALT instruction
        if z inc di
        jmp end_of_z80_instr

find_end_instr:
        test byte cs:countt,0ff         ;Counting T states?
        jnz find_end_ctt
        PUSH ES                         ;Now single step until end of
        XOR AX,AX                       ; z80 instruction is found
        MOV ES,AX
        LES bx,ES:[4]
        MOV CS:oldint3a,bx
        MOV CS:oldint3s,ES
        mov es,ax
        MOV ES:W[4],DO_INSTRUCTION
        MOV ES:[6],CS
        POP ES
        POP BP
        POP DX
        POP CX
        POP BX
        POP AX
        CALL SAVE_REGS
        MOV BYTE CS:WORKSP,0    ;Signal: we didn't leave emulator segment
        mov byte cs:intimer,0ff ;Signal: we're single stepping now
DO_INSTRUCTION:
        STI
        PUSH BP
        PUSH ES
        push ax
check_instr:
        MOV BP,SP
        OR b[BP+11],01          ;ZET TRAPFLAG (WEER) AAN
        AND b[BP+11],0FD        ;ZET IF UIT
        LES BP,[BP+6]           ;HAAL SEG/ADR VAN VOLGENDE INSTRUCTIE
        cmp bp,offset haltwait
        jz found_halt
        mov ax,es:[bp]
        cmp ax,03d8a            ;mov bh,[di]
        jz found_end
        cmp al,09c              ;pushf
        jz do_pushf
        cmp al,09d              ;popf
        jz do_popf
        cmp al,090
        jz do_nothing           ;but do it very quickly
        MOV ax,ES
        CMP ax,SEG EMULATE
        JNZ LEAVEIT
NEXT_INSTR:
        pop ax
        POP ES
        POP BP
        IRET                    ;NAAR DO_INSTRUCTION
DO_PUSHF:
        PUSHF                   ;allocate one word on the stack
        MOV BP,SP
        mov ax,[bp+2]           ;old ax
        mov [bp],ax
        MOV ax,[BP+4]           ;OUDE ES
        MOV [BP+2],ax
        MOV ax,[BP+6]           ;OUDE BP
        MOV [BP+4],ax
        MOV ax,[BP+8]           ;OUDE IP
        INC ax                  ;VOLGENDE INSTRUCTIE
        MOV [BP+6],ax
        MOV ax,[BP+10]          ;OUDE CS
        MOV [BP+8],ax
        MOV ax,[BP+12]          ;OUDE FLAGS
        MOV [BP+10],ax
        and ah,0fe              ;reset TF of pushed flags
        or ah,2                 ;set IF of pushed flags
        mov [bp+12],ax
        JMP check_instr
DO_POPF:
        MOV BP,SP
        OR W[BP+12],0100       ;ZET TF AAN VAN TE POPPEN FLAGS
        JMP next_instr
found_halt:                     ;If the break is just after a HALT *and*
        test byte cs:c_active   ;we're going to C *and* no NMI or interrupt
        jz found_end_2          ;occurs now, then go on HALTing
        test byte cs:nmi
        jnz found_end_2
        dec di
        jmp short found_end_2
LEAVEIT:
        MOV BYTE CS:WORKSP,0FF  ;signal: don't activate interrupt/c
        JMP SHORT FOUND_END_2
do_nothing:
        inc bp
        cmp es:w[bp],03d8a
        jne do_nothing
        mov bx,sp
        mov ss:[bx+6],bp        ;store new value of IP
        xor bx,bx               ;reset BX, which may've been used as a counter
FOUND_END:
        CMP ES:[BP+2],0E3FF     ;JMP BX
        JNZ next_instr
FOUND_END_2:
        mov byte cs:intimer,0   ;Signal: not single stepping anymore
        pop ax
        POP ES
        POP BP
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        PUSH BP
        PUSH ES
        XOR AX,AX
        MOV ES,AX
        MOV AX,CS:oldint3a
        MOV ES:[4],AX
        MOV AX,CS:oldint3s
        MOV ES:[6],AX
        POP ES
        MOV BP,SP
        AND W[BP+14],0FEFF              ;ZET TF UIT
        OR W[BP+14],0200                ;ZET IF AAN
        TEST BYTE CS:WORKSP             ;Do not activate c or generate irpt
        if NZ jmp endint                      ; if worksp<>0
;
;Now handle the interrupt, NMI or reset
;
end_of_z80_instr:
        cmp byte cs:nmi,080             ;reset?
        jne no_reset
        mov al,byte cs:if1flg           ;IF1 or Disciple or Multiface rom paged?
        or al,cs:byte discflg
        or al,cs:byte m128flg
        if nz call far pagin_n_rom_far
        CALL RESET_ALL
        MOV word cs:IFF,0               ;disable interrupt
        mov di,0                        ;jump to 0
no_reset:
        cmp byte cs:nmi,0ff             ;nmi?
        jne no_nmi
        cmp byte cs:rommod,2            ;reset samram
        if z CALL RESET_ALL
        call switchon_m128
        mov cs:byte iff,0
        jmp short call_interr
no_nmi:
        cmp byte cs:nmi,0fe             ;interrupt?
        jne no_interrupt_0
        test byte cs:[offset iff],0ff
        jne probably_interrupt
no_interrupt_0:
        jmp no_interrupt
probably_interrupt:
        MOV cs:W[OFFSET IFF],0
        cmp byte cs:IMODE,1
        ja mode2
        if e dec cs:w[_tstates]
        sub cs:w[_tstates],12   ;IM0 takes 12 T states, IM1 takes 13
        jmp short call_interr
mode2:
        sub cs:w[_tstates],19   ;IM2 takes 19 T states
call_interr:
        inc byte es:rr          ;Interrupt or NMI takes 1 R update! (v3.04)
        pop bp
        dec bp
        mov ax,di
        call testbp2
        if c mov ds:[bp],ah
        dec bp
        call testbp2
        if c mov ds:[bp],al
        push bp
        mov di,066
        cmp byte cs:nmi,0ff
        je no_interrupt_0
        mov di,038
        cmp byte cs:imode,2
        jne no_interrupt_0
        mov bh,cs:ri
        cmp byte cs:amsmouse,0ff
        jne interr_noams
        mov bl,cs:rommod
        and bl,0fe
        je interr_ams
        cmp bl,2
        jne interr_noams        ;only ams mouse emulation in mode 0,1,4,5
interr_ams:
        cmp byte cs:amsienablea,0
        je interr_noamsa
        cmp byte cs:amsmodea,1
        jne interr_noamsa
        cmp byte cs:amscnta,0
        je interr_noamsa
        dec byte cs:amscnta
        mov bl,cs:amsiveca
        mov byte cs:ams38irupt,0ff
        jmp mode2_interrupt
interr_noamsa:
        cmp byte cs:amsienableb,0
        je interr_noams
        cmp byte cs:amsmodeb,1
        jne interr_noams
        cmp byte cs:amscntb,0
        je interr_noams
        dec byte cs:amscntb
        mov bl,cs:amsivecb
        mov byte cs:ams38irupt,0ff
        jmp mode2_interrupt
interr_noams:
        mov bl,0ff
mode2_interrupt:
        mov al,[bx]
        mov ah,[bx+1]
        mov di,ax
no_interrupt:
        mov byte cs:nmi,0
        mov word cs:trapadr,offset emulate_0    ;Do not update R twice!
        mov word cs:trapseg,seg emulate_0
        test byte cs:countt
        je ordinary_timinter
        test byte cs:c_active
        mov byte cs:c_active,0
        pop bp
        pop dx
        pop cx
        pop bx
        pop ax
        if nz jmp far enter_c
        jmp far emulate_0               ;continue emulating

ordinary_timinter:
        mov bp,sp
        TEST BYTE CS:C_ACTIVE
        JZ NOT_C_ACT
        MOV W[BP+10],OFFSET ENTER_C
        MOV W[BP+12],SEG ENTER_C
        JMP SHORT C_ACT
NOT_C_ACT:
        MOV W[BP+10],OFFSET emulate_0
        MOV W[BP+12],SEG emulate_0
C_ACT:
        MOV BYTE CS:C_ACTIVE,0          ;ACTION CODE VOOR 'C' IN C_ACTION_CODE
ENDINT:
        POP BP
        POP DX
        POP CX
        POP BX
        test byte cs:countt,0ff         ;Called from the T state counter?
        jne endint_countt               ;If so, jump to the emulator
endint1:
;        cmp byte cs:modflg,0            ;<>0 = real mode
;        je endint_normal
;        pop ax
;        iret
;endint_normal:
        MOV AX,CS:TIMNUM
        STC
        ADC AX,CS:ADDNUM
        MOV CS:TIMNUM,AX
        POP AX
        jnc iret_label
        cmp byte cs:wkbd_count,0        ;decrease windows compatibility kbd
        if ne dec byte cs:wkbd_count    ; counter (see above)
        jmp cs:d[timadr]
iret_label:
        IRET

endint_countt:
        pop ax
        cmp byte cs:wkbd_count,0        ;decrease windows compatibility kbd
        if ne dec byte cs:wkbd_count    ; counter (see above)
        jmp far emulate_0               ;Continue emulating



;
;De volgende routine berekent de gewenste vertragingsfactor voor SLOWMOD
;gegeven de maximale relatieve snelheid (tov echte Spectrum) in promilles
;in RELSPD0 en een gewenste snelheid in AX. Na afloop is SLOWMOD goedgezet.
;Een aanroep van HOESNEL geeft in AX de snelheid in promilles terug.
;Deze wijkt iha af van de gewenste snelheid.
;Een aanroep van RREG_EMUL is nog nodig om de snelheidsverandering
;werkelijkheid te maken.
;
speed_convert:
        mov ax,cs:_curspd
        mov bx,offset slowmod
        mov cx,4
spdc_loop:
        push ax
        push bx
        push cx
        call spdc_cx_tstates
        pop cx
        pop bx
        pop ax
        add bx,2
        inc cx
        cmp cx,23
        jbe spdc_loop
        ret
spdc_cx_tstates:
        push bx
        cmp ax,60000
        if b mov ax,60000
        push ax
        call getrelspd0
        mov dx,ax
        pop ax
        cmp dx,ax
        ja speed_slower
speed_fastest:
        xor ax,ax
        jmp short spd_gotit
speed_slower:
        mov bx,ax               ;k = (1/65536) T (n/512) (174483/v' - 174483/v)
        mov ax,43621            ; bxcst = n/512
        mul cx
        add ax,ax
        adc dx,dx
        add ax,ax
        adc dx,dx
        push ax
        push dx
        div bx                  ; 174483 = 65536*(1000*18.2*512/3.5M)
        add dx,dx
        cmp dx,bx
        if a inc ax
        mov bx,ax
        call getrelspd0         ;destroys dx
        mov cx,ax
        pop dx
        pop ax
        div cx
        sub bx,ax
        add dx,dx
        cmp dx,cx
        if a dec bx
        mov ax,bx
        mul word cs:bxcst
        mov ax,dx
        cmp ax,2
        jbe speed_fastest
        sub ax,4
        if c xor ax,ax
        inc ax
spd_gotit:
        pop bx
        mov cs:w[bx],ax
        ret



getrelspd0:                     ;get speed without slowdown, but taking into
        mov ax,cs:relspd0       ; account R register and hi color res. emulation
        test byte cs:mflag,1
        jz no_rreg
        mov dx,50412            ;65536* (1/1.3), for R reg. emulation
        mul dx
        mov ax,dx
no_rreg:
;        test byte cs:coloremu,0ff
        test byte cs:countt,0ff
        jz ret
        mov dx,43690            ;65536* (1/1.5) for coloremu on 386+
        cmp cs:cputype,386
        jae hs_386
        mov dx,36921            ;65536* (1/1.775) for coloremu on 286-
hs_386:
        mul dx
        mov ax,dx
        ret



hoesnel:
;
;Nops needed for slowdown from v to v' for a T T-state instruction is
;k=N*18.2*(1000T/v' - 1000T/v)/3.5*10^6
;where v,v' are max,desired speed in promilles and N is the number of nops
;the computer executes in a 1/18.2 s timeslice. BXCST contains N/512.
;So, given k, the actual speed is
;v'=(v*c/[k*v/N + c] where c=T*1000*18.2/(3.5*10^6)=1744831/(512*65536)
;with T=10, which is a reasonable choice (above average (T=6) so it 'feels'
;the slowdown in the slower instructions, but not too high since it must
;reflect the starting treshold, the JMP to the slowdown routine)
;  The first jump takes about the time of 4 NOPs. k=0 corresponds to no
;slowdown, k=1 to JMP & no nops etc.
;
        call getrelspd0         ;and make correction for R register & color emu
        mov bx,ax
        mov ax,cs:w[offset slowmod+12]          ;10 T state instruction
        test ax
        if nz add ax,3          ;treshold
        mul bx
        push bx                 ;save v (adjusted for R register emulation)
        mov cl,12               ;*65536/32 (=2^11)
        mov bx,cs:bxcst
shl_numer:
        add ax,ax
        adc dx,dx
        jc numer_toobig
        cmp dx,bx
        jae numer_toobig
        dec cl
        jnz shl_numer
        inc cl
        clc
numer_toobig:                   ;cl: 1+number of bits dxax is to be shiftlefted
        rcr dx,1
        rcr ax,1
        div bx
        push cx
        mov bx,54526            ;=(65536*512*10*1000*18.2/3.5M)/32
        dec cl
        if nz shr bx,cl
        pop cx
        add ax,bx
        pop dx                  ;v
        pushf
        if c rcr ax,1
        mov bx,ax
        mov ax,54526
        mul dx
        popf
        jnc hoesnel_nodiv2
        shr dx,1
        rcr ax,1
hoesnel_nodiv2:
        div bx
        add dx,dx
        cmp dx,bx
        if a inc ax
        dec cl
        if nz shr ax,cl
        push ax
        mov bx,ax
        mov ax,91               ;1000* (18.2/200)
        xor dx,dx
        div bx
        inc ax
        mov cs:maxtel,al
        mul bx
        mov bx,ax
        xor ax,ax
        mov dx,91
        div bx
        cmp ax,512
        if b mov ax,512         ;To make sure timer is never programmed with
        mov cs:addnum,ax        ; a too small time interval. 512 =/= 2330 Hz
        pop ax                  ; =/= 1165 %, maximum is 1000% anyway.
        ret



startup ends
