startup segment para public

xherc   equ 0
plant   equ 0

INIT_VIDEO:
        MOV AH,0F
        INT 010
        MOV CS:OLD_MODE,AL
#if xherc
        CMP BYTE CS:XTDHERC,0FF
        IF Z JMP INIT_XTD_HERC
#endif
        CMP BYTE CS:HERCFLG,0FF
        if Z jmp INIT_HERC
        CMP BYTE CS:CGA,0FF
        if Z jmp INIT_CGA
        CMP BYTE CS:EGA,0FF
        IF Z JMP INIT_EGA
        cmp byte cs:vga,0ff
        if z jmp init_vga
#if plant
        CMP BYTE CS:PLANTR,0FF
        IF Z JMP INIT_PLANTR
#endif

        push es
        push cs
        pop es
        mov di,offset vga_workspace
        xor bx,bx
        mov ax,01b00
        int 010
        pop es
        cmp al,01b
        if z jmp init_vga

        mov bl,010                      ;return ega info
        mov ah,012
        int 010
        cmp bl,010
        if nz jmp init_ega

#if plant
        CALL GET_TT
        CMP CS:BYTE TTYPE,1
        IF NZ JMP INIT_PLANTR
#endif

        CALL HERCPRESENT
        CMP AL,1
        JZ INIT_HERC

        mov dx,03d4
        mov al,0f
        out dx,al
        inc dx
        in al,dx
        xchg ah,al
        mov al,0bf
        out dx,al
        mov cx,0100
waitCRT:
        loop waitCRT
        in al,dx
        xchg ah,al
        out dx,al
        cmp ah,0bf
        if e jmp init_cga

        MOV AH,09
        MOV DX,OFFSET VIDMES
        PUSH CS
        POP DS
        INT 021
        MOV AX,04C01
        INT 021



INIT_CGA:
;initialiseer CGA
        MOV BYTE CS:GMOD,0           ;'CGA'
        CALL PRVK
        MOV AX,04
        INT 010
        MOV AH,0B
        XOR BX,BX
        INT 010
        MOV AH,0B
        MOV BX,0101
        INT 010
        RET
;initialiseer Hercules
INIT_HERC:
        MOV BYTE CS:GMOD,1           ;'HERC', VOOR SCHERM EMULATIE SPECTRUM
        CALL PRVK
        MOV BYTE CS:MODE,1           ;GRAFISCHE MODE, VOOR SETMODE
INIT_HERC2:
        CALL SETMODE
        PUSH ES
        MOV AX,0B000
        MOV ES,AX
        XOR AX,AX
        MOV DI,AX
        MOV CX,04000
        REP STOSW
        POP ES
        RET
#if xherc
INIT_XTD_HERC:
        MOV BYTE CS:GMOD,2
        CALL PRVK
        MOV BYTE CS:MODE,2
        JMP INIT_HERC2
#endif

#if plant
INIT_PLANTR:
        MOV BYTE CS:GMOD,3              ;'PLANTRONICS'
        CALL PRVK
        MOV BYTE CS:MODE,1              ;GRAFISCH
        CALL GET_TT                     ;HAAL TERMINAL TYPE OP
        CALL SETMODE
        PUSH ES
        MOV AX,0B000
        MOV ES,AX
        XOR AX,AX
        MOV DI,AX
        MOV CX,08000
        REP STOSW
        POP ES
        RET
#endif

INIT_EGA:
        MOV BYTE CS:GMOD,4           ;'EGA'
        CALL PRVK
        MOV AX,0d
        INT 010
        mov dx,ega_list
        cmp cs:byte egapal,0
        if nz mov dx,ega_list_2
        mov ax,01002
        push es
        push cs
        pop es
        push cs
        pop ds
        int 010
        pop es
        ret

EGA_LIST:
EGA_BORDER_PALETTE:
        db 0,1,4,5,2,19,22,23,0,1,20,21,18,19,22,23,0
EGA_LIST_2:
        db 0,5,5,7,40,56,56,63,0,5,5,7,40,56,56,63,0

init_vga:
        push es
        push cs
        pop es
        mov di,offset vga_workspace
        xor bx,bx
        mov ax,01b00
        int 010
        pop es
        mov al,cs:b[offset vga_workspace+02a]
        mov cs:vgascan,al
        mov byte cs:gmod,5              ;vga
        call prvk
        mov ax,3                        ;Needed for unknown reason.
        int 010
        push es
        push cs
        pop es
        mov ax,01200                    ;Select 200 scan lines.
        mov bl,030
        int 010
        mov ax,1                        ;Mode 1
        int 010
        xor al,al
        mov di,offset vga_workspace
        mov cx,0100
initv_1:
        stosb
        cmp byte cs:trivga,0ff
        if z stosb
        inc al
        loop initv_1
        mov cx,0100
        mov bx,0100
        xor dx,dx
        mov bp,offset vga_workspace
        cmp byte cs:trivga,0ff          ;Changes here by Samir Ribic
        jnz initv_no_xv
        mov  ax, 01100
        mov  bx,0200
        int  010
        mov  dx,03D4
        mov  al,9
        out  dx,al
        inc  dx
        mov  al,1
        out  dx,al
        jmp initv_continue
initv_no_xv:
        mov ax,01110
        mov bx,0100
        int 010
initv_continue:
        mov ah,1
        mov cx,0100
        int 010
        cmp byte cs:greyvga,0ff
        jnz keep_blue
        mov cs:b[offset vga_palette+3],25
        mov cs:b[offset vga_palette+27],25
keep_blue:
        mov ax,01012
        mov dx,offset vga_palette
        xor bx,bx
        mov cx,16
        int 010
        cmp byte cs:greyvga,0ff
        jnz geen_robkleuren
        mov ax,0101b
        xor bx,bx
        mov cx,16
        int 010
geen_robkleuren:
        mov dx,03da
        in al,dx
        mov dx,03c0
        mov al,030                      ;Bit 5: no snow
        out dx,al
        inc dl
        in al,dx
        and al,011110100xb              ;No blinking, Color attributes
        mov bl,al                       ; and Alphanumeric
        mov dx,03da
        in al,dx
        mov dx,03c0
        mov al,030
        out dx,al
        mov al,bl
        out dx,al
        mov cx,16
        mov al,0
initv_palette:                          ;Initialise the 16 attributes
        out dx,al
        jmp $+2
        out dx,al
        inc al
        loop initv_palette
        mov al,8                       ;Border
        out dx,al
        xor al,al
        out dx,al
        mov al,49                       ;Overscan
        out dx,al
        xor al,al
        out dx,al
        mov di,offset vga_workspace
        mov cx,0200
        xor bl,bl
initv_attrs:
        mov al,bl
        mov ah,al
        shr al,1
        shr al,1
        shr al,1
        and ax,0707
        test bl,64
        if nz add ax,0808
        cmp al,8
        if z xor al,al
        cmp ah,8
        if z xor ah,ah
        cmp cx,0100
        ja initv_noflash
        test bl,128
        if nz xchg al,ah
initv_noflash:
        shl al,1
        shl al,1
        shl al,1
        shl al,1
        or al,ah
        stosb
        inc bl
        loop initv_attrs
        mov cx,768
        xor bx,bx
initv_table:
        mov ax,bx
        and ax,0ffe0
        mov dx,10
        mul dx
        mov dx,bx
        and dx,31
        add ax,dx
        add ax,ax
        add ax,4*40*2+4*2+1
        stosw
        inc bx
        loop initv_table
        mov cx,6144/2
        xor bx,bx
initv_table2:
        push cx
        mov ax,bx
        and ax,31
        add ax,ax
        mov si,ax
        mov ax,bx
        and ax,224
        mov cl,5
        shr ax,cl
        mov dx,80*8
        mul dx
        add si,ax
        mov ax,bx
        and ax,1792
        xchg al,ah
        mov dx,80
        mul dx
        add si,ax
        mov ax,bx
        and ax,6144
        xchg al,ah
        mov cl,3
        shr ax,cl
        mov dx,64*80
        mul dx
        add ax,si
        add ax,4*40*2+4*2
        stosw
        pop cx
        inc bx
        inc bx
        loop initv_table2
        mov di,offset vga_coloremu_table
        mov bx,16384
        mov cx,192
initv_table3:
        mov ax,bx
        shr ah,1
        shr ah,1
        shr ah,1
        add ah,80               ;now ax is attr address corr. to bx
        sub ax,bx               ;now ax is attr offset rel. to bx
        sub ax,32               ;see get_line in miscp2.8
        stosw
        mov ax,bx
        stosw                   ;and store display address
        inc bh                  ;new pixel line
        test bh,7
        jne initvt3_ok
        add bx,32-8*256         ;new char line
        test bl,bl
        jne initvt3_ok
        add bx,2048-8*32        ;new third
initvt3_ok:
        loop initv_table3
        mov ax,0b800
        mov es,ax
        xor di,di
        mov ax,08800                    ;All border
        mov cx,8000
        rep stosw
        cmp cs:trivga,0ff
        jz vga_optionxv
        push ds
        mov ax,seg _flash               ;dummy variable
        mov ds,ax
        mov es,ax
        call far _printmes
        pop ds
vga_optionxv:
        pop es
        ret

vga_palette:
        db 0,0,0, 0,0,40, 55,0,0, 57,0,45, 0,53,0, 0,53,53, 52,52,0, 50,50,50
        db 0,0,0, 0,0,43, 60,0,0, 63,0,55, 0,60,0, 0,63,63, 63,63,0, 63,63,63

HERC_TABLES:
        DB 32,061,050,052,0F,019,06,019,019,02,0D,0B,0C
        DB 2, 035,02D,02E,07,05B,02,058,058,02,03,0 ,0
        DB 2, 035,02A,02B,0A,064,02,061,061,02,03,0 ,0

#if plant
PLANTR_TABLES:
        DB 071,050,05A,0A,01F,06,019,01C,02,07,06,07,0,0,0,0
        db 038,028,02d,0a,07f,06,064,070,02,01,06,07,0,0,0,0
        db 038,028,02d,0a,07f,06,064,070,02,01,06,07,0,0,0,0
#endif

HERCPRESENT:
        MOV BX,0100
        MOV DX,03BA
        IN AL,DX
        MOV AH,AL
        AND AH,080
WAIT_EV_2:
        MOV CX,040
WAIT_FOR_EVENT:
        IN AL,DX
        AND AL,080
        CMP AL,AH
        LOOPE WAIT_FOR_EVENT
        JNE GOT_EVENT
        DEC BX
        JNE WAIT_EV_2
        JMP HERC_NOT_FOUND

GOT_EVENT:
        MOV AX,0B000
        MOV ES,AX
        CALL CHECK_RAM
        JNE FOUND_HERC
        MOV AL,1
        MOV DX,03BF
        OUT DX,AL
        CALL CHECK_RAM
        JE HERC_NOT_FOUND
FOUND_HERC:
        MOV AL,1
        RET
HERC_NOT_FOUND:
        XOR AL,AL
        RET
CHECK_RAM:
        ES MOV BL,B[07FFF]
        ES MOV CL,B[03FFF]
        ES INC B[03FFF]
        ES CMP BL,B[03FFF]
        ES MOV B[03FFF],CL
        RET

#if plant
GET_TT:
        CMP CS:BYTE TTYPE,0
        JNZ RET
        MOV CS:BYTE TTYPE,1     ;'GEEN PLANTRONICS'
        PUSH ES
        XOR AX,AX
        MOV ES,AX
        CMP ES:W[0463],03D4
        POP ES
        JNZ RET
        MOV AH,0
        INT 01A
        MOV BX,DX
WAIT_TIM:
        MOV AH,0
        INT 01A
        CMP BX,DX
        JZ WAIT_TIM
        MOV DX,BX
        XOR CX,CX
WAIT_TIM2:
        MOV AH,0
        INT 01A
        CMP BX,DX
        JZ WAIT_TIM2
COUNTIT:
        MOV DX,03DA
        IN AL,DX
        AND AL,8
        JnZ COUNTIT
COUNTIT2:
        IN AL,DX
        AND AL,8
        JZ COUNTIT2
        INC CX
        CMP CX,40
        JNZ COUNTIT
        MOV AH,0
        INT 01A
        SUB DX,BX
        CMP DX,14
        JB RET
        CMP DX,19
        JA RET
        MOV CS:BYTE TTYPE,2     ;EMULATION MODE
        CMP DX,16
        JA RET
        MOV CS:BYTE TTYPE,3     ;COLOR MODE
        RET
#endif

SETMODE:
#if plant
        CMP CS:BYTE GMOD,3
        JZ SETMOD_PLANTR
#endif
        MOV AL,CS:MODE
        CMP AL,2
        IF A MOV AL,1
        MOV AH,0D
        MUL AH
        MOV SI,AX
        ADD SI,HERC_TABLES
        MOV DX,03BF
        MOV AL,1
        OUT DX,AL
        MOV AL,CS:[SI]
        MOV DL,0B8
        OUT DX,AL
        MOV CX,0
        MOV DL,0B4
NOT_EOT:
        MOV AL,CL
        OUT DX,AL
        INC SI
        MOV AL,CS:[SI]
        INC DX
        OUT DX,AL
        DEC DX
        INC CX
        CMP CL,0C
        JNE NOT_EOT
        SUB SI,0C
        MOV AL,CS:[SI]
        OR AL,8
        MOV DL,0B8
        OUT DX,AL
        RET
#if plant
SETMOD_PLANTR:                  ;MODE 0=TEXT, 1=GRAPH (ADHV TTYPE)
        MOV DX,03D8
        MOV AL,2
        OUT DX,AL
        CMP CS:BYTE MODE,0
        JZ SETMOD_PLANTR_TEXT
        CMP CS:BYTE TTYPE,2
        JZ SETMOD_PLANTR_EMUL
        MOV DL,0DD
        mov al,010
        OUT DX,AL
        MOV DL,0D8
        MOV AL,2
        OUT DX,AL
        MOV BX,OFFSET PLANTR_TABLES+32
        CALL PROGRAM_CRT
        MOV AL,0A
        OUT DX,AL
        MOV AL,030
        INC DL
        OUT DX,AL
        MOV DL,0DD
        mov al,010
        OUT DX,AL
        RET
SETMOD_PLANTR_EMUL:
        MOV DL,0DD
        mov al,010
        OUT DX,AL
        MOV DL,0DF
        MOV AL,0A2
        OUT DX,AL
        MOV DL,0D8
        MOV AL,2
        OUT DX,AL
        MOV BX,OFFSET PLANTR_TABLES+16
        CALL PROGRAM_CRT
        MOV AL,0A
        OUT DX,AL
        INC DL
        MOV AL,030
        OUT DX,AL
        MOV DL,0DF
        MOV AL,0A0
        OUT DX,AL
        mov al,010
        MOV DL,0DD
        OUT DX,AL
        RET
SETMOD_PLANTR_TEXT:
        MOV DL,0DD
        XOR AL,AL
        OUT DX,AL
        MOV DL,0D8
        MOV AL,025
        OUT DX,AL
        MOV BX,OFFSET PLANTR_TABLES
        CALL PROGRAM_CRT
        MOV AL,02D
        OUT DX,AL
        INC DL
        MOV AL,030
        OUT DX,AL
        MOV DL,0DD
        XOR AL,AL
        OUT DX,AL
        RET
PROGRAM_CRT:
        MOV DX,03D4
        MOV AH,0
PROGRAM_CRT_LOOP:
        XCHG AH,AL
        OUT DX,AL
        XCHG AH,AL
        INC DL
        MOV AL,CS:[BX]
        INC BX
        OUT DX,AL
        DEC DL
        INC AH
        CMP AH,16
        JNZ PROGRAM_CRT_LOOP
        MOV DX,03D8
        RET
#endif

PRVK:   MOV DX,OFFSET VIDEOKAART
        PUSH DS
        PUSH CS
        POP DS
        MOV AH,9
        INT 021
        MOV AL,GMOD
        MOV DX,OFFSET VK1
        CMP AL,1
        IF Z MOV DX,OFFSET VK2
        CMP AL,2
        IF Z MOV DX,OFFSET VK3
        CMP AL,4
        IF Z MOV DX,OFFSET VK4
        CMP AL,3
        IF Z MOV DX,OFFSET VK5
        cmp al,5
        if z mov dx,offset vk6
        MOV AH,9
        INT 021
        POP DS
        CALL SAVE_SCREEN
        RET

text_mode:
        cmp cs:gmod,5
        jnz no_vga
        mov ah,012
        mov al,cs:vgascan
        mov bl,030
        int 010                         ;Reset # scanlines
no_vga: CMP BYTE CS:GMOD,1              ;HERCULES
        JZ hercc
        cmp byte cs:gmod,2
        jz hercc
        cmp byte cs:gmod,3              ;Plantronics
        jNz NO_HERC2
hercc:
        MOV BYTE CS:MODE,0              ;HERCULES TEXT / plantronics off
        CALL SETMODE
NO_HERC2:
        MOV AL,CS:OLD_MODE
        MOV AH,0
        INT 010
        jmp GET_SCREEN




flashcount:
        mov bl,15
        cmp byte cs:flash,0
        if nz mov bl,7
        mov al,cs:flshcnt
        inc al
        mov cs:flshcnt,al
        test al,bl
        jz ret
        mov byte cs:fflag,0ff
        inc bl
        test al,bl
        mov ax,0100
        if z dec ah
        mov cs:fstate,ax
        ret



VIDEO_UPDATE:
        PUSH SI
        PUSH DI
        PUSH BP
        PUSH DX
        PUSH ES
        push ds
        STD
        mov ds,cs:specseg
        MOV ES,CS:VIDBUFSEG
        cmp byte cs:rommod,4            ;HMc
        jb one_screen
        test byte cs:hstate,8           ;Is the screen at page 7?
        je one_screen                   ;Nope, page 5 is (fixed at 4000)
        cmp byte cs:[ramstate+3],10     ;Hope it is paged in bank 3
        je second_at_c000
        test word cs:emshandle          ;Hope we're not using EMS
        je second_in_ram
        mov ax,010a
        call swap_mem
        stc                             ;Signal: restore memory state afterwards!!
        pushf
        jmp short two_screens
second_in_ram:
        mov ax,cs:romseg
        add ax,9*0400
        push ax
        pop ds                  ;ds:04000 = page 7, int. page 10
        jmp short one_screen
second_at_c000:
        push ds
        pop ax
        add ax,0800
        push ax
        pop ds
one_screen:
        clc
        pushf                   ;This signals: memory state hasn't changed
two_screens:
        test byte cs:fflag
        mov byte cs:fflag,0
        je start_vid_emulating
        MOV SI,23294
        MOV CX,768/2
ZERO_FLASH:
        LODSW
        AND AX,08080
        not ax
        and ES:[si+2],ax
        LOOP ZERO_FLASH
START_VID_EMULATING:
        mov ax,cs:fstate
        cmp byte cs:gmod,5
        jne not_vga
        add ax,offset vga_workspace
        mov cs:[offset atrpokvga],ax
        mov cs:[offset atrpokvga2],ax
        jmp vga_emul
not_vga:
        MOV SI,16384+6910
        MOV DI,SI
        MOV CX,768/2
        CMP BYTE CS:GMOD,1      ;1=Hercules
        jne no_herc
        add ax,attr_tab-0100
        mov cs:[offset atrpok3],ax
        mov cs:[offset atrpok4],ax
        jmp herc_emul
no_herc:
#if xherc
        CMP BYTE CS:GMOD,2      ;2=XTD HERC
        jne no_xherc
        add ax,attr_tab-0100
        mov cs:[offset atrpok5],ax
        mov cs:[offset atrpok6],ax
        mov cs:[offset atrpok7],ax
        mov cs:[offset atrpok8],ax
        jmp xtd_herc_emul
no_xherc:
#endif
        CMP BYTE CS:GMOD,4      ;4=EGA
        jne no_ega
        add ax,attr_tab+0200
        mov cs:[offset atrpok9],ax
        mov cs:[offset atrpoka],ax
        jmp ega_emul
no_ega:
#if plant
        CMP BYTE CS:GMOD,3      ;3=PLANTRONICS
        jne no_plant
        add ax,cs:atradr
        dec ah
        mov cs:[offset atrpokb1],ax
        mov cs:[offset atrpokc1],ax
        add ax,0300
        mov cs:[offset atrpokb2],ax
        mov cs:[offset atrpokc2],ax
        jmp plant_emul
no_plant:
#endif
        add ax,attr_tab-0100
        mov cs:[offset atrpok1],ax
        mov cs:[offset atrpok2],ax
ATTR_SCAN:
        REPZ CMPSW
        JZ START_SCREEN_SCAN
        call addrconvert
        CALL EMULATTR_CGA
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP ATTR_SCAN
l1:     inc cx
        cmp al,al
        jmp attr_scan
START_SCREEN_SCAN:
        MOV CX,6144/2
SCREEN_SCAN:
        REPZ CMPSw
        JZ END_VID_UPDATE
        call addrconvert
        CALL EMULSCRN_CGA
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP screen_SCAN
l1:     inc cx
        cmp al,al
        JMP SCREEN_SCAN
END_VID_UPDATE:
        MOV AL,CS:NEWBOR
        AND AL,7
        CMP AL,CS:BORCLR
        JZ NO_EMUL
        MOV CS:BORCLR,AL
        CMP BYTE CS:GMOD,0
        IF Z CALL BOREMUL_CGA
        CMP BYTE CS:GMOD,1
        IF Z CALL BOREMUL_HERC
#if xherc
        CMP BYTE CS:GMOD,2
        IF Z CALL BOREMUL_X_HERC
#endif
        CMP BYTE CS:GMOD,4
        IF Z CALL BOREMUL_EGA
#if plant
        CMP BYTE CS:GMOD,3
        IF Z CALL BOREMUL_PLANT
#endif
        cmp byte cs:gmod,5
        if z call boremul_vga
NO_EMUL:
        popf
        mov ax,0108
        if c call swap_mem
        pop ds
        POP ES
        POP DX
        POP BP
        POP DI
        POP SI
        RET

HERC_EMUL:
        REPZ CMPSw
        JZ START_SCREEN_SCAN_HERC
        call addrconvert
        CALL EMULATTR_herc
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP herc_emul
l1:     inc cx
        cmp al,al
        JMP HERC_EMUL
START_SCREEN_SCAN_HERC:
        MOV CX,6144/2
SCREEN_SCAN_HERC:
        REPZ CMPSw
        if Z jmp END_VID_UPDATE
        call addrconvert
        CALL EMULSCRN_HERC
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP screen_SCAN_herc
l1:     inc cx
        cmp al,al
        JMP SCREEN_SCAN_HERC

#if xherc
XTD_HERC_EMUL:
        REPZ CMPSw
        JZ START_SCREEN_SCAN_X_HERC
        call addrconvert
        CALL EMULATTR_x_herc
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP xtd_herc_emul
l1:     inc cx
        cmp al,al
        JMP XTD_HERC_EMUL
START_SCREEN_SCAN_X_HERC:
        MOV CX,6144/2
SCREEN_SCAN_X_HERC:
        REPZ CMPSw
        if Z jmp END_VID_UPDATE
        call addrconvert
        CALL EMULSCRN_X_HERC
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP screen_SCAN_x_herc
l1:     inc cx
        cmp al,al
        JMP SCREEN_SCAN_X_HERC
#endif

#if plant
PLANT_EMUL:
        REPZ CMPSw
        JZ START_SCREEN_SCAN_PLANT
        call addrconvert
        CALL EMULATTR_PLANT
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP plant_emul
l1:     inc cx
        cmp al,al
        JMP PLANT_EMUL
START_SCREEN_SCAN_PLANT:
        MOV CX,6144/2
SCREEN_SCAN_PLANT:
        REPZ CMPSw
        if Z jmp END_VID_UPDATE
        call addrconvert
        CALL EMULSCRN_PLANT
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP screen_SCAN_plant
l1:     inc cx
        cmp al,al
        JMP SCREEN_SCAN_PLANT
#endif

EGA_EMUL:
        MOV DX,03CE
        mov ax,03
        out dx,ax
        MOV AX,0205
        OUT DX,AX                       ;WRITE MODE 2, READ MODE 0
EGA_EMUL_LOOP:
        REPZ CMPSw
        JZ START_SCREEN_SCAN_EGA
        call addrconvert
        CALL EMULATTR_EGA
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP ega_emul_loop
l1:     inc cx
        cmp al,al
        JMP EGA_EMUL_LOOP
START_SCREEN_SCAN_EGA:
        MOV CX,6144/2
SCREEN_SCAN_EGA:
        REPZ CMPSw
        JZ END_VID_UPDATE_EGA
        call addrconvert
        CALL EMULSCRN_EGA
        shr cx,1
        jc >l1
        dec si
        dec di
        cmp al,al
        JMP screen_SCAN_ega
l1:     inc cx
        cmp al,al
        JMP SCREEN_SCAN_EGA
END_VID_UPDATE_EGA:
        mov dx,03da
        in al,dx
        mov dl,0ce
        mov ax,0ff08
        out dx,ax
        mov ax,5
        out dx,ax
        mov ax,3
        out dx,ax
        JMP END_VID_UPDATE


vga_emul_386:
        mov si,16384
vga_3blocks_386:
        mov di,si
        mov cx,6144/12
        mov dx,0b800
        mov bp,ds
        cmp al,al
vga_scremul_386:
        repz
        db 066
        cmpsw                   ;repz cmpsd
        jz vga_attremul_386
        sub si,4
        mov di,si
        db 066
        lodsw                   ;lodsd
        db 066
        stosw                   ;stosd
        mov bx,cs:[si+vga_scrn_addrs-16388]
        mov ds,dx
        mov [bx],al
        mov [bx+2],ah
        db 066
        shr ax,16               ;shr eax,16
        mov [bx+4],al
        mov [bx+6],ah
        mov ds,bp
        xor al,al
        jmp vga_scremul_386
vga_attremul_386:
        mov cx,768/12           ;si=16384+n*2048 (1,2,3)
        shr si,3                ;si=2048+n*256
        add si,20480-256        ;si+22528+n*256 (0,1,2)
        mov di,si
vga_attr_386:
        repz
        db 066
        cmpsw                   ;repz cmpsd
        jz vga_nextblock_386
        push cx
        sub si,4
        mov di,si
        db 066
        lodsw                   ;lodsd
        db 066
        mov cx,es:[di]          ;mov ecx,es:[di]
        db 066
        xor cx,ax               ;xor ecx,eax
        db 066
        stosw                   ;(stosd)  now DI = atr.addr (0-767) + 22528 + 4
        add di,di               ;2*atr.addr + 45064
        mov di,cs:w[di+vga_attr_addrs-45064]
        mov bx,offset vga_workspace
atrpokvga2 equ $-2
        stc
vga_attrbyte_386:
        db 066
        rcr cx,1                ;rcr ecx,1
        jnc vga_nocheckend_386
        db 066
        test cx,cx              ;test ecx,ecx
        je vga_next4block_386
        jmp short vga_updatethis_386
vga_nocheckend_386:
        test cl,07f
        je vga_attrbyte_loop_386
vga_updatethis_386:
        cs:xlatb
        mov ds,dx
        mov b[di],al
        mov b[di+80],al
        mov b[di+160],al
        mov b[di+240],al
        mov b[di+320],al
        mov b[di+400],al
        mov b[di+480],al
        mov b[di+560],al
        mov ds,bp
vga_attrbyte_loop_386:
        db 066
        shr ax,8                ;shr eax,8
        db 066
        shr cx,7                ;shr ecx,7
        add di,2                ;nc
        jmp vga_attrbyte_386
vga_next4block_386:             ;ZF = 1
        mov di,si
        pop cx
        jmp vga_attr_386
vga_nextblock_386:              ;SI = 22528+n*256 (1,2,3)
        shl si,3                ;SI = 49152+n*2048
        add si,08000            ;SI = 16384+n*2048
        cmp si,22528
        if ne jmp vga_3blocks_386
        jmp end_vid_update_vga



vgaborder_update:
        cmp cs:gmod,5
        jne ret
        mov dx,03da
        in al,dx
        mov dl,0c0
        mov al,8
        out dx,al
        jmp $+2
        mov al,cs:newbor
        and al,7
        out dx,al
        mov al,49
        out dx,al
        push es
        push di
        mov ax,0b800
        mov es,ax
        xor di,di
        mov cx,4*40+4
        mov ax,08800
        cld
        rep stosw
        mov cx,192
restore_brder:
        add di,64
        stosw
        stosw
        stosw
        stosw
        stosw
        stosw
        stosw
        stosw
        loop restore_brder
        mov cx,4*40-4
        rep stosw
        pop di
        pop es
        ret



vga_emul_hcrmode:
        mov si,16384
        mov di,si
        mov cx,6912/2
ved_1:  lodsw
        not ax
        stosw
        loop ved_1
        push es
        mov es,cs:vgahcrbuf
        mov si,16384
        mov di,164+16384
        mov bl,192
ved_0:  mov cx,32/2
        rep movsw
        add si,256-32
        test si,2048-256
        jne ved_00
        add si,32-2048
        test si,255
        jne ved_00
        add si,2048-256
ved_00:
        add di,8
        dec bl
        jne ved_0
        mov bl,24
        mov di,16384+8192+164
ved_2:  mov bh,8
ved_3:  mov cx,32/2
        rep movsw
        add di,8
        sub si,32
        dec bh
        jne ved_3
        add si,32
        dec bl
        jne ved_2
        push ds
        push es
        pop ds
        mov si,16384
        mov di,0
        mov cx,(8192+164+40*192)/2
        rep movsw
        pop ds
        pop es
        call vgaborder_update
        ret



vga_emul:                               ;With improvements by Steve O'Brien
        cld
        cmp byte cs:coloremu,0ff
        jne vga_emul_normal
        call vga_emul_hcrmode
vga_emul_normal:
        cmp cs:word cputype,386
        if ae jmp vga_emul_386
        mov si,16384
vga_3blocks:
        mov di,si
        mov cx,6144/6
        mov dx,0b800
        mov bp,ds
        cmp al,al
vga_scremul_86:
        repz cmpsw
        jz vga_attremul
        sub si,2
        mov di,si
        lodsw
        stosw
        mov bx,cs:[si+vga_scrn_addrs-16386]
        mov ds,dx
        mov [bx],al
        mov [bx+2],ah
        mov ds,bp
        xor al,al
        jmp vga_scremul_86
vga_attremul:
        mov cx,768/3
        cmp si,16384+4096
        mov si,22528
        jb vga_attr0
        mov si,22528+256
        jz vga_attr0
        mov si,22528+512
vga_attr0:
        mov di,si
vga_attr:
        repz cmpsb
        jz vga_nextblock
vga_attr2:
        push di
        dec si
        add di,si
        sub di,45057
        mov di,cs:w[di+vga_attr_addrs]
        mov bx,offset vga_workspace
atrpokvga equ $-2
        lodsb
        mov es:b[si-1],al
        cs:xlatb
        mov ds,dx                       ;dx remains the same here (S O'B)
        mov b[di],al
        mov b[di+80],al
        mov b[di+160],al
        mov b[di+240],al
        mov b[di+320],al
        mov b[di+400],al
        mov b[di+480],al
        mov b[di+560],al
        mov ds,bp                       ;S O'B
        pop di
        cmp al,al
        jmp vga_attr
vga_nextblock:                  ;SI = 22528+n*256 (1,2,3)
        mov cl,3
        shl si,cl               ;SI = 49152+n*2048
        add si,08000            ;SI = 16384+n*2048
        cmp si,22528
        if ne jmp vga_3blocks
end_vid_update_vga:
        cmp byte cs:coloremu,0ff
        if ne jmp end_vid_update
        mov es,cs:vgahcrborbuf
        mov al,cs:newbor
        mov es:[2],al
        mov es:w[0],0
        mov byte cs:bornochange,-3
        mov byte cs:vgahcrborbufptr,3
        jmp end_vid_update


boremul_vga:
        and al,7
        mov ah,al
        mov dx,03da
boremul_overscan:
        in al,dx
        test al,1
        jz boremul_overscan
        mov dl,0c0
        mov al,8
        out dx,al
        mov al,ah
        out dx,al
        mov al,49               ;overscan
        out dx,al
        mov al,ah
        test byte cs:coloremu,0ff
        if ne xor al,al         ;hi res color emulation -> no oversacn
        out dx,al
        ret


BOREMUL_CGA:
        MOV CX,0B800
        PUSH CX
        POP ES
        XOR DI,DI
        mov cx,2
        SHR AL,cl
        rcl ch,1
        shr al,1
        rcl ch,1
        mov al,ch
        MOV CL,2
        SHL al,CL
        OR AL,CH
        mov ch,al
        mov cl,4
        SHL CH,CL
        OR AL,CH
        MOV AH,AL
        CLD
        CALL BOR_LOOP_CGA
        MOV DI,02000
BOR_LOOP_CGA:
        MOV CX,4
        REP STOSW
        MOV DL,95
BOR_LOP2_CGA:
        ADD DI,64
        MOV CL,8
        REP STOSW
        DEC DL
        JNZ BOR_LOP2_CGA
        ADD DI,64
        MOV CL,4
        REP STOSW
        RET

#if plant
BOREMUL_PLANT:
        MOV CX,0B800
        PUSH CX
        POP ES
        MOV DI,CS:ATRADR
        MOV BL,AL
        XOR BH,BH
        ADD BX,BX
        MOV AL,CS:[DI+BX]
        MOV BL,CS:[DI+BX+0300]
        MOV AH,AL
        MOV BH,BL
        XOR DI,DI
        CLD
        CALL BOR_LOOP_plant
        MOV DI,02000
BOR_LOOP_plant:
        mov cx,96
blcp:   stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        add di,64
        stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        stosw
        mov es:[di+04000-2],bx
        loop blcp
        RET
#endif

BOREMUL_HERC:
        MOV CX,0B000
        MOV ES,CX
        XOR DI,DI
        SHR AL,1
        mov cx,2
        shr al,1
        rcl ch,1
        shr al,1
        rcl ch,1
        mov al,ch
        SHL CH,CL
        OR AL,CH
        SHL CH,CL
        OR AL,CH
        SHL CH,CL
        OR AL,CH
        MOV AH,AL
        CLD
        MOV CX,855              ;(76/4)*90
        PUSH CX
        PUSH CX
        PUSH CX
        REP STOSW
        POP CX
        MOV DI,02000
        REP STOSW
        POP CX
        MOV DI,04000
        REP STOSW
        POP CX
        MOV DI,06000
        REP STOSW
        MOV DI,06AE
        CALL BOR_LOOP_HERC
        MOV DI,026AE
        CALL BOR_LOOP_HERC
        MOV DI,046AE
        CALL BOR_LOOP_HERC
        MOV DI,066AE
        CALL BOR_LOOP_HERC
        MOV DI,0178E
        MOV CX,1800
        PUSH CX
        PUSH CX
        PUSH CX
        REP STOSW
        POP CX
        MOV DI,0378E
        REP STOSW
        POP CX
        MOV DI,0578E
        REP STOSW
        POP CX
        MOV DI,0778E
        REP STOSW
        RET
BOR_LOOP_HERC:
        MOV CX,6
        REP STOSW
        STOSB
        MOV DL,47
BOR_LOP2_HERC:
        ADD DI,64
        MOV CL,13
        REP STOSW
        DEC DL
        JNZ BOR_LOP2_HERC
        ADD DI,64
        MOV CL,6
        REP STOSW
        STOSB
        RET

#if xherc
BOREMUL_X_HERC:
        MOV CX,0B000
        MOV ES,CX
        XOR DI,DI
        MOV AH,AL
        SHR AL,1
        MOV CH,0
        SHR AL,1
        RCL CH,1
        SHR AL,1
        RCL CH,1
        MOV AL,CH
        MOV CL,2
        SHL CH,CL
        OR AL,CH
        SHL CH,CL
        OR AL,CH
        SHL CH,CL
        OR AL,CH
        INC AH
        TEST AH,2
        PUSHF
        AND AH,6
        CMP AH,4
        MOV AH,AL
        MOV BX,AX
        IF E NOT AX
        POPF
        IF NE XOR AX,01010101010101010XB
        CLD
        CALL BOR_LOOP_X_HERC
        MOV DI,02000
        XCHG AX,BX
        CALL BOR_LOOP_X_HERC
        MOV DI,04000
        XCHG AX,BX
        CALL BOR_LOOP_X_HERC
        MOV DI,06000
        XCHG AX,BX
BOR_LOOP_X_HERC:
        MOV CX,5
        REP STOSW
        MOV DL,95
BOR_LOP2_X_HERC:
        ADD DI,64
        MOV CL,10
        REP STOSW
        DEC DL
        JNZ BOR_LOP2_X_HERC
        ADD DI,64
        MOV CL,5
        REP STOSW
        RET
#endif

BOREMUL_EGA:
        and al,07
        push ax
        mov bx,ega_border_palette
        cs:xlatb
        mov ah,al
        pushf
        cli
        mov dx,03da
        in al,dx
        mov dl,0c0
        mov al,031
        out dx,al
        mov al,ah
        out dx,al
        popf
        pop ax
        mov ah,al
        mov al,0
        mov dx,03ce
        out dx,ax               ;set/reset register laden met kleur
        mov ax,0ff08
        out dx,ax               ;alle pixels selecteren
        mov ax,0f01
        out dx,ax               ;enable set/reset reg laden met 0f
        mov ax,5                
        out dx,ax               ;write mode 0
        mov ax,3
        out dx,ax
        MOV DX,0A000
        MOV ES,DX
        CLD
        xor di,di
        mov cx,4*20             ;4 lijnen van 40 bytes
        rep stosw
        MOV CX,192              ;192 LIJNEN
LOOP_LINE:
        STOSW
        STOSW                   ;4 BYTES LINKS, EN ....
        ADD DI,32
        STOSW
        STOSW                   ;...4 BYTES RECHTS.
        LOOP LOOP_LINE
        mov cx,4*20
        rep stosw
        MOV AX,1
        mov dx,03ce
        OUT DX,AX
        MOV AX,0205
        OUT DX,AX               ;RESTORE WRITE MODE 2
        RET


ADDRCONVERT:                    ;Deze routine is nodig omdat de emulattr
        shl cx,1                ;routines uitgaan van een REPZ CMPSB en er
        mov al,b[si+3]          ;vanaf versie 1.40 een REPZ CMPSW gepleegd
        cmp al,es:[di+3]        ;wordt.
        jz aac_lowbyte
        inc si
        inc di
        inc cx
aac_lowbyte:
        inc si
        inc di
        ret

#if plant
emulattr_plant:
        PUSH SI
        PUSH DI
        PUSH CX
        INC SI
        MOV BX,SI
        MOV CL,4
        SAL BH,CL
        ROR BH,1                ;BX IS NU ADRES IN SPECTRUM-SCHERM
        PUSH BX                 ;BEWAAR POINTER
        MOV AL,BL               ;AL=X COORD
        SHR BX,CL               ;SCHUIF DE Y-COORDINAAT-BITS NAAR BL
        AND BX,0111111110XB     ;BX=2*Y
        MOV BP,CS:[SCREEN_ADDRESSES_CGA+BX]    ;BP IS plant SCREEN-ADDRESS
        SAL AL,1                ;X KEER 2
        AND AX,111110XB         ;ALLEEN DE X-COORDINAAT OVERHOUDEN
        ADD BP,AX               ;BP=plant ADDRESS

NEXT_BYTE_plant:                  ;ENTRY POINT ALS 2 BYTES NAAST ELKAAR VER-
                                ;ANDERD ZIJN.
        MOV BL,[SI]             ;HAAL SPECTRUM ATTR
        MOV ES:[SI],BL
        XOR BH,BH
        SAL BX,1                ;VERM MET 2
        MOV cX,CS:[ATTRp1+BX]   ;HAAL ATTR lo DATA (low=ink)
atrpokb1        equ $-2
        mov dx,cs:[attrp2+bx]   ;haal 2e attr data (hi) (low=ink)
ATRPOKb2        EQU $-2
        POP BX                  ;HAAL SPECTRUM BLD-ADRES TERUG
        mov ah,8
BYTE8LOOP_plant:
                                ;VERANDER plant-BYTE OP BP, MET ATTR DATA
                                ;IN SI/DI EN BLD-ADRES IN BX
        MOV aL,[BX]             ;aL=DATA
        MOV ES:[BX],aL          ;ZET EVT. NIEUWE BYTE IN BUFFER
        inc bh
        push es
        push bx
        push ax
        mov bl,al
        xor bh,bh
        shl bx,1
        MOV BX,CS:[BX+GRAPHIC_TABLE]       ;HAAL GRAFISCHE DATA
        mov ax,bx
        not ax
        push bx
        push ax
        and al,ch
        and ah,ch
        and bl,cl
        and bh,cl
        or bx,ax
        mov ax,0b800
        mov es,ax
        mov es:[bp],bx
        pop ax
        pop bx
        and al,dh
        and ah,dh
        and bl,dl
        and bh,dl
        or ax,bx
        mov es:[bp+04000],ax
        add bp,02000
        cmp bp,04000
        if ae add bp,-04000+80
        pop ax
        pop bx
        pop es
        dec ah
        jnz byte8loop_plant

        POP CX
        POP DI
        POP SI
        TEST CL,31
        JZ RET                  ;RETURN ALS DIT DE LAATSTE ATTR-BYTE WAS VAN
                                ; DEZE REGEL (ZF=1)
        DEC CL
        CMPSB
        jz ret
        ADD BP,0FEBE            ;= 4*-80 -2
        ADD BX,0F7FF
        PUSH SI
        PUSH DI
        PUSH CX
        PUSH BX
        INC SI
        JMP NEXT_BYTE_plant
        RET






EMULSCRN_PLANT:
        PUSH CX
        INC SI                  ;MAAK GOEDE ADRES

        MOV BX,SI               ;BEREKEN SPECTRUM-ATTR ADRES
        MOV CL,3
        SHR BH,CL
        OR BH,050               ;BX IS NU ATTR ADRES
        mov bp,bx               ;bp=attr

        mov bx,si
        MOV CH,BL               ;CH=X
        INC CL
        SHR BX,CL               ;BX 4 NAAR RECHTS
        AND BL,0FE              ;HAAL LAATSTE BIT VAN X WEG. BX IS NU 2*Y+1024
        MOV CL,CH
        SHL CL,1                ;CX=X*2
        AND CX,0111110XB        ;HOU ALLEEN X-BITS OVER (MAAK CH 0)
        MOV BX,CS:[SCREEN_ADDRESSES_MINUS_1024_CGA+BX]
        ADD cx,bX               ;cx IS NU plant ADRES

;De adressen zijn nu berekend; nu worden de waarden opgehaald.

CONTINUE_EMULATING_plant:
        MOV BL,ds:[bp]          ;HAAL ATTR
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        push cx                 ;bewaar plant adres
        MOV AX,CS:[attrp1+BX]   ;HAAL IN AX DE ATTR DATA
ATRPOKc1        EQU $-2
        mov cx,cs:[attrp2+bx]   ;haal in cx de 2e attr data
atrpokc2        equ $-2
        MOV BL,[SI]             ;HAAL DE GRAFISCHE DATA
        MOV ES:[SI],BL          ;ZET GR.DATA IN VIDEO BUFFER
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        MOV DX,CS:[GRAPHIC_TABLE+BX]

        DEC SI                  ;MAAK GOEDE ADRES
        pop bx                  ;haal in bx plant adres
        push es
        push cx                 ;bewaar 2e attr data
        push dx                 ;bewaar grafische data

        MOV CX,DX               ;BEREKEN ATTR/GRAPHIC plant DATA
        NOT CX
        AND CH,Ah
        AND CL,Ah
        AND DH,Al
        AND DL,Al
        OR CX,DX

        MOV AX,0B800
        MOV ES,AX
        MOV ES:[BX],CX

        pop dx
        pop cx
        mov ax,dx
        not ax
        and ah,ch
        and al,ch
        and dh,cl
        and dl,cl
        or ax,dx
        mov es:[bx+04000],ax

        pop es
        POP CX
        TEST CL,31
        JZ RET                ;ERUIT ALS EINDE VD REGEL (OF VID.BUF.)
        DEC CL
        CMPSB
        JZ RET                  ;ERUIT ALS BYTES GELIJK
        PUSH CX
        LEA CX,[BX-2]           ;CX=NIEUW plant-ADRES
        DEC BP                  ;BP=NIEUW ATTR-ADRES
        INC SI
        JMP CONTINUE_EMULATING_plant
        RET
#endif


EMULATTR_EGA:
        PUSH SI
        PUSH DI
        PUSH CX
        INC SI
        MOV BX,SI
        MOV CL,4
        SHL BH,CL
        ROR BH,1                ;BX IS NU ADRES IN SPECTRUM-SCHERM
        PUSH BX                 ;BEWAAR POINTER
        MOV AL,BL               ;AL=X COORD
        SHR BX,CL               ;SCHUIF DE Y-COORDINAAT-BITS NAAR BL
        AND BX,0111111110XB     ;BX=2*Y
        MOV BP,CS:[SCREEN_ADDRESSES_EGA+BX]    ;BP IS EGA SCREEN-ADDRESS
        AND AX,11111XB          ;ALLEEN DE X-COORDINAAT OVERHOUDEN
        add ax,4*40             ;4 regels naar beneden (voor border)
        ADD BP,AX               ;BP=EGA ADDRESS

NEXT_BYTE_EGA:                  ;ENTRY POINT ALS 2 BYTES NAAST ELKAAR VER-
                                ;ANDERD ZIJN.
        MOV BL,[SI]             ;HAAL SPECTRUM ATTR
        MOV ES:[SI],BL
        XOR BH,BH
        SAL BX,1                ;VERM MET 2
        MOV CX,CS:[ATTR_TAB_EGA+BX]     ;HAAL ATTR DATA
ATRPOK9 EQU $-2


        POP BX                  ;HAAL SPECTRUM BLD-ADRES TERUG
        MOV DX,03CE
        MOV AH,8
BYTE8LOOP_EGA:
        PUSH AX
                                ;VERANDER EGA-BYTE OP BP, MET ATTR DATA
                                ;IN CX EN BLD-ADRES IN BX
        MOV AX,0FF08            ;Alle bits selecteren
        OUT DX,AX
        MOV AH,[BX]             ;Haal binary image
        MOV ES:[BX],AH          ;ZET IN SHADOW VID BUFFER
        PUSH ES
        MOV DX,0A000
        MOV ES,DX
        mov dl,es:[bp]          ;Latch oude informatie
        mov dx,03ce
        mov ES:[BP],CH
        OUT DX,AX               ;Binary image naar bit mask register
        MOV AL,ES:[BP]          ; (in al zat nog 08) Latch informatie
        MOV ES:[BP],CL
        POP ES
        ADD BP,40               ;VOLGENDE EGA REGEL
        INC BH                  ;VOLGENDE SPECTRUM BEELDLIJN
        POP AX
        DEC AH
        JNZ BYTE8LOOP_EGA

        POP CX
        POP DI
        POP SI
        TEST CL,31
        JZ RET_EGA              ;RETURN ALS DIT DE LAATSTE ATTR-BYTE WAS VAN
                                ; DEZE REGEL (ZF=1)
        DEC CL
        CMPSB
        JZ RET_EGA              ;TERUG ALS VOLGENDE NIET VERANDERD IS (ZF=1)
        ADD BP,-321             ;8*-40 - 1
        ADD BX,0F7FF
        PUSH SI
        PUSH DI
        PUSH CX
        PUSH BX
        INC SI
        JMP NEXT_BYTE_EGA
RET_EGA:
        RET



EMULSCRN_EGA:
        PUSH CX
        PUSH DI
        INC SI                  ;MAAK GOEDE ADRES

        MOV BX,SI               ;BEREKEN SPECTRUM-ATTR ADRES
        MOV CL,3
        SHR BH,CL
        OR BH,050               ;BX IS NU ATTR ADRES
        mov bp,bx               ;bp=attr

        mov bx,si
        MOV CH,BL               ;CH=X
        INC CL
        SHR BX,CL               ;BX 4 NAAR RECHTS
        AND BL,0FE              ;HAAL LAATSTE BIT VAN X WEG. BX IS NU 2*Y+1024
        MOV CL,CH
        AND CX,011111XB         ;HOU ALLEEN X-BITS OVER (MAAK CH 0)
        add cx,4*40             ;4 regels naar beneden (voor border)
        ADD CX,CS:[SCREEN_ADDRESSES_MINUS_1024_EGA+BX]
                                ;CX IS NU EGA ADRES

;De adressen zijn nu berekend; nu worden de waarden opgehaald.

CONTINUE_EMULATING_EGA:
        PUSH CX
        MOV BL,ds:[bp]          ;HAAL ATTR (ZET NIET IN SHADOW BUFFER, WANT
        XOR BH,BH               ; ALS DAT HAD GEHOEVEN, WAS DEZE BYTE AL
                                ; VERVERST DOOR EMUL_ATTR)
        SHL BX,1                ;MAAL 2
        MOV CX,CS:[ATTR_TAB_EGA+BX]     ;HAAL IN CX DE ATTR DATA
ATRPOKA EQU $-2
        POP BX
        MOV Ah,[SI]             ;HAAL DE GRAFISCHE DATA
        MOV ES:[SI],Ah          ;ZET GR.DATA IN VIDEO BUFFER

        DEC SI                  ;MAAK GOEDE ADRES


        PUSH ES
        MOV Al,8
        PUSH AX
        MOV Ah,0ff
        MOV DX,03CE
        OUT DX,AX
        MOV AX,0A000
        MOV ES,AX
        MOV ES:[BX],CH          ;KLEUR PAPER
        POP AX
        OUT DX,AX               ;BITMASK PAPER
        mov al,es:[bx]
        MOV ES:[BX],CL          ;KLEUR INK
        POP ES

        POP DI
        POP CX
        TEST CL,31
        IF Z JMP RET_EGA        ;ERUIT ALS EINDE VD REGEL (OF VID.BUF.)
        DEC CL
        CMPSB
        IF Z JMP RET_EGA        ;ERUIT ALS BYTES GELIJK
        PUSH CX
        PUSH DI
        MOV CX,BX
        DEC CX                  ;CX=NIEUW EGA ADRES
        DEC BP                  ;BP=NIEUW ATTR-ADRES
        INC SI
        JMP CONTINUE_EMULATING_EGA







EMULATTR_CGA:
        PUSH SI
        PUSH DI
        PUSH CX
        INC SI
        MOV BX,SI
        MOV CL,4
        SAL BH,CL
        ROR BH,1                ;BX IS NU ADRES IN SPECTRUM-SCHERM
        PUSH BX                 ;BEWAAR POINTER
        MOV AL,BL               ;AL=X COORD
        SHR BX,CL               ;SCHUIF DE Y-COORDINAAT-BITS NAAR BL
        AND BX,0111111110XB     ;BX=2*Y
        MOV BP,CS:[SCREEN_ADDRESSES_CGA+BX]    ;BP IS CGA SCREEN-ADDRESS
        SAL AL,1                ;X KEER 2
        AND AX,111110XB         ;ALLEEN DE X-COORDINAAT OVERHOUDEN
        ADD BP,AX               ;BP=CGA ADDRESS

NEXT_BYTE_CGA:                  ;ENTRY POINT ALS 2 BYTES NAAST ELKAAR VER-
                                ;ANDERD ZIJN.
        MOV BL,[SI]             ;HAAL SPECTRUM ATTR
        MOV ES:[SI],BL
        XOR BH,BH
        SAL BX,1                ;VERM MET 2
        MOV AX,CS:[ATTR_TAB+BX] ;HAAL ATTR DATA
ATRPOK1 EQU $-2
        MOV BL,AH
        MOV BH,AH
        MOV DI,BX
        MOV AH,AL
        MOV SI,AX               ;SI=PAPER KLEUR, DI=INK


        POP BX                  ;HAAL SPECTRUM BLD-ADRES TERUG
        MOV CX,02000
        MOV DX,0E050            ;DE CONSTANTEN VOOR NEXT CGA ADRES
        MOV AH,8
BYTE8LOOP_CGA:
        PUSH DX
                                ;VERANDER CGA-BYTE OP BP, MET ATTR DATA
                                ;IN SI/DI EN BLD-ADRES IN BX

        PUSH BX                 ;BEWAAR SPECTRUM ADRES
        MOV DL,[BX]             ;BL=DATA
        MOV ES:[BX],DL          ;ZET EVT. NIEUWE BYTE IN BUFFER
        MOV BH,0
        MOV BL,DL
        SHL BX,1                ;BX=BX*2
        MOV BX,CS:[BX+GRAPHIC_TABLE]       ;HAAL GRAFISCHE DATA
        MOV DX,BX
        NOT DX                  ;DX=NOT BX
        AND DX,SI
        AND BX,DI
        OR BX,DX
        PUSH ES
        MOV DX,0B800
        MOV ES,DX
        MOV ES:[BP],BX
        POP ES
        POP BX
        INC BH                  ;VOLGENDE BEELDLIJN

        POP DX                  ;ANDERE VOLGORDE!
        XCHG CX,DX
        ADD BP,DX               ;OM-EN-OM OPTELLEN: 02000 EN 0E050
        DEC AH
        JNZ BYTE8LOOP_CGA

        POP CX
        POP DI
        POP SI
        TEST CL,31
        JZ RET                  ;RETURN ALS DIT DE LAATSTE ATTR-BYTE WAS VAN
                                ; DEZE REGEL (ZF=1)
        DEC CL
        CMPSB
        JZ RET                  ;TERUG ALS VOLGENDE NIET VERANDERD IS (ZF=1)
        ADD BP,0FEBE            ;= 4*-80 -2
        ADD BX,0F7FF
        PUSH SI
        PUSH DI
        PUSH CX
        PUSH BX
        INC SI
        JMP NEXT_BYTE_CGA
        RET



EMULSCRN_CGA:
        PUSH CX
        INC SI                  ;MAAK GOEDE ADRES

        MOV BX,SI               ;BEREKEN SPECTRUM-ATTR ADRES
        MOV CL,3
        SHR BH,CL
        OR BH,050               ;BX IS NU ATTR ADRES
        mov bp,bx               ;bp=attr

        mov bx,si
        MOV CH,BL               ;CH=X
        INC CL
        SHR BX,CL               ;BX 4 NAAR RECHTS
        AND BL,0FE              ;HAAL LAATSTE BIT VAN X WEG. BX IS NU 2*Y+1024
        MOV CL,CH
        SHL CL,1                ;CX=X*2
        AND CX,0111110XB        ;HOU ALLEEN X-BITS OVER (MAAK CH 0)
        MOV BX,CS:[SCREEN_ADDRESSES_MINUS_1024_CGA+BX]
        ADD cx,bX               ;cx IS NU CGA ADRES

;De adressen zijn nu berekend; nu worden de waarden opgehaald.

CONTINUE_EMULATING_CGA:
        MOV BL,ds:[bp]          ;HAAL ATTR
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        MOV AX,CS:[ATTR_TAB+BX] ;HAAL IN AX DE ATTR DATA
ATRPOK2 EQU $-2
        MOV BL,[SI]             ;HAAL DE GRAFISCHE DATA
        MOV ES:[SI],BL          ;ZET GR.DATA IN VIDEO BUFFER
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        MOV DX,CS:[GRAPHIC_TABLE+BX]

        DEC SI                  ;MAAK GOEDE ADRES

        MOV BX,CX               ;BX IS NU CGA ADRES
        MOV CX,DX               ;BEREKEN ATTR/GRAPHIC CGA DATA
        NOT CX
        AND CH,AL
        AND CL,AL
        AND DH,AH
        AND DL,AH
        OR CX,DX

        PUSH ES                 ;ZET DATA OP CGA SCHERM
        MOV AX,0B800
        MOV ES,AX
        MOV ES:[BX],CX
        POP ES
        POP CX
        TEST CL,31
        JZ RET                ;ERUIT ALS EINDE VD REGEL (OF VID.BUF.)
        DEC CL
        CMPSB
        JZ RET                  ;ERUIT ALS BYTES GELIJK
        PUSH CX
        LEA CX,[BX-2]           ;CX=NIEUW CGA-ADRES
        DEC BP                  ;BP=NIEUW ATTR-ADRES
        INC SI
        JMP CONTINUE_EMULATING_CGA
        RET






;Hercules emulatie routines; bijna hetzelfde als de CGA routines, gebruiken
;andere tabel uit TABLES.8 en stellen het zonder snowcheck

EMULATTR_HERC:
        PUSH SI
        PUSH DI
        PUSH CX
        INC SI
        MOV BX,SI
        MOV CL,4
        SAL BH,CL
        ROR BH,1                ;BX IS NU ADRES IN SPECTRUM-SCHERM
        PUSH BX                 ;BEWAAR POINTER
        MOV AL,BL               ;AL=X COORD
        SHR BX,CL               ;SCHUIF DE Y-COORDINAAT-BITS NAAR BL
        AND BX,0111111110XB     ;BX=2*Y
        MOV BP,CS:[SCREEN_ADDRESSES_HERC+BX]    ;BP IS HERC SCREEN-ADDRESS
        SAL AL,1                ;X KEER 2
        AND AX,111110XB         ;ALLEEN DE X-COORDINAAT OVERHOUDEN
        ADD BP,AX               ;BP=CGA ADDRESS

NEXT_BYTE_HERC:                 ;ENTRY POINT ALS 2 BYTES NAAST ELKAAR VER-
                                ;ANDERD ZIJN.
        MOV BL,[SI]             ;HAAL SPECTRUM ATTR
        MOV ES:[SI],BL          ;ZET IN BUFFER
        MOV BH,0
        SAL BX,1                ;VERM MET 2
        MOV AX,CS:[ATTR_TAB+BX] ;HAAL ATTR DATA
ATRPOK3 EQU $-2
        PUSH AX
        MOV AH,AL
        MOV SI,AX               ;SI=PAPER KLEUR
        POP AX
        MOV AL,AH               ;AX=INK
        MOV DI,AX               ;SI=PAP,DI=INK


        POP BX                  ;HAAL SPECTRUM BLD-ADRES TERUG
        MOV AH,8
BYTE8LOOP_HERC:
                                ;VERANDER CGA-BYTE OP BP, MET ATTR DATA
                                ;IN SI/DI EN BLD-ADRES IN BX
        PUSH BX                 ;BEWAAR SPECTRUM ADRES
        MOV DL,[BX]             ;BL=DATA
        MOV ES:[BX],DL          ;ZET EVT. NIEUWE BYTE IN BUFFER
        MOV BH,0
        MOV BL,DL
        SHL BX,1                ;BX=BX*2
        MOV BX,CS:[BX+GRAPHIC_TABLE]       ;HAAL GRAFISCHE DATA
        MOV DX,BX
        NOT DX                  ;DX=NOT BX
        AND DX,SI
        AND BX,DI
        OR BX,DX
        PUSH ES
        MOV CX,0B000
        MOV ES,CX
        MOV ES:[BP],BX
        POP ES
        POP BX
        INC BH                  ;VOLGENDE BEELDLIJN
        ADD BP,02000            ;VOLGENDE HERC BEELDLIJN
        IF S ADD BP,0805A       ;4*-02000 + DEC. 90
        DEC AH
        JNZ BYTE8LOOP_HERC

        POP CX
        POP DI
        POP SI
        TEST CL,31
        JZ RET                  ;RETURN ALS DIT DE LAATSTE ATTR-BYTE WAS VAN
                                ; DEZE REGEL (ZF=1)
        DEC CL
        CMPSB
        JZ RET                  ;TERUG ALS VOLGENDE NIET VERANDERD IS (ZF=1)
        ADD BP,0FF4A            ;= 2*-90 -2
        ADD BX,0F7FF
        PUSH SI
        PUSH DI
        PUSH CX
        PUSH BX
        INC SI
        JMP NEXT_BYTE_HERC
        RET



EMULSCRN_HERC:
        PUSH CX
        INC SI                  ;MAAK GOEDE ADRES

        MOV BX,SI               ;BEREKEN SPECTRUM-ATTR ADRES
        MOV CL,3
        SHR BH,CL
        OR BH,050               ;BX IS NU ATTR ADRES
        mov bp,bx               ;bp=attr

        mov bx,si
        MOV CH,BL               ;CH=X
        INC CL
        SHR BX,CL               ;BX 4 NAAR RECHTS
        AND BL,0FE              ;HAAL LAATSTE BIT VAN X WEG. BX IS NU 2*Y+1024
        MOV CL,CH
        SHL CL,1                ;CX=X*2
        AND CX,0111110XB        ;HOU ALLEEN X-BITS OVER (MAAK CH 0)
        MOV BX,CS:[SCREEN_ADDRESSES_MINUS_1024_HERC+BX]
        ADD cx,bX               ;cx IS NU CGA ADRES

;De adressen zijn nu berekend; nu worden de waarden opgehaald.

CONTINUE_EMULATING_HERC:
        MOV BL,ds:[bp]          ;HAAL ATTR
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        MOV AX,CS:[ATTR_TAB+BX] ;HAAL IN AX DE ATTR DATA
ATRPOK4 EQU $-2
        MOV BL,[SI]             ;HAAL DE GRAFISCHE DATA
        MOV ES:[SI],BL          ;ZET GR.DATA IN VIDEO BUFFER
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        MOV DX,CS:[GRAPHIC_TABLE+BX]

        DEC SI                  ;MAAK GOEDE ADRES

        MOV BX,CX               ;BX IS NU HERC ADRES
        MOV CX,DX               ;BEREKEN ATTR/GRAPHIC CGA DATA
        NOT CX
        AND CH,AL
        AND CL,AL
        AND DH,AH
        AND DL,AH
        OR CX,DX

        PUSH ES                 ;ZET DATA OP HERC SCHERM
        MOV AX,0B000
        MOV ES,AX
        MOV ES:[BX],CX
        POP ES
        POP CX
        TEST CL,31
        JZ RET                  ;ERUIT ALS EINDE VD REGEL (OF VID.BUF.)
        DEC CL
        CMPSB
        JZ RET                  ;ERUIT ALS BYTES GELIJK
        PUSH CX
        LEA CX,[BX-2]           ;CX=NIEUW HERC-ADRES
        DEC BP                  ;BP=NIEUW ATTR-ADRES
        INC SI
        JMP CONTINUE_EMULATING_HERC
        RET



#if xherc
EMULATTR_X_HERC:
        PUSH SI
        PUSH DI
        PUSH CX
        INC SI
        MOV BX,SI
        MOV CL,4
        SAL BH,CL
        ROR BH,1                ;BX IS NU ADRES IN SPECTRUM-SCHERM
        PUSH BX                 ;BEWAAR POINTER
        MOV AL,BL               ;AL=X COORD
        SHR BX,CL               ;SCHUIF DE Y-COORDINAAT-BITS NAAR BL
        AND BX,0111111110XB     ;BX=2*Y
        MOV BP,CS:[SCREEN_ADDRESSES_X_HERC+BX]    ;BP IS HERC SCREEN-ADDRESS
        SAL AL,1                ;X KEER 2
        AND AX,111110XB         ;ALLEEN DE X-COORDINAAT OVERHOUDEN
        ADD BP,AX               ;BP=CGA ADDRESS

NEXT_BYTE_X_HERC:               ;ENTRY POINT ALS 2 BYTES NAAST ELKAAR VER-
                                ;ANDERD ZIJN.
        MOV BL,[SI]             ;HAAL SPECTRUM ATTR
        MOV ES:[SI],BL          ;ZET IN BUFFER
        MOV AL,BL
        XOR BH,BH
        SAL BX,1                ;VERM MET 2
        MOV DX,CS:[ATTR_TAB+BX] ;HAAL ATTR DATA
ATRPOK5 EQU $-2
        MOV BX,OFFSET XLATTAB
        CS:XLATB                ;MAAK ANDERE ATTR, VOOR 2E RIJ
        MOV BL,AL
        XOR BH,BH
        SAL BX,1
        MOV AX,CS:[ATTR_TAB+BX]
ATRPOK6 EQU $-2
        MOV BH,AH
        MOV BL,AH
        MOV DI,BX               ;DI=INK
        MOV AH,AL
        MOV SI,AX               ;SI=PAPER KLEUR


        POP BX                  ;HAAL SPECTRUM BLD-ADRES TERUG
        MOV AH,8
BYTE8LOOP_X_HERC:
                                ;VERANDER CGA-BYTE OP BP, MET ATTR DATA
                                ;IN SI/DI EN BLD-ADRES IN BX
        PUSH BX                 ;BEWAAR SPECTRUM ADRES
        MOV AL,[BX]             ;AL=DATA
        MOV ES:[BX],AL          ;ZET EVT. NIEUWE BYTE IN BUFFER
        MOV BH,0
        MOV BL,AL
        SHL BX,1                ;BX=BX*2
        MOV BX,CS:[BX+GRAPHIC_TABLE]       ;HAAL GRAFISCHE DATA
        PUSH ES
        PUSH BX
        MOV CX,BX
        NOT CX                  ;DX=NOT BX
        AND CX,SI
        AND BX,DI
        OR BX,CX

        MOV CX,0B000
        MOV ES,CX
        POP CX
        MOV ES:[BP],BX
        MOV BL,DH
        MOV BH,DH
        AND BX,CX
        NOT CX
        AND CH,DL
        AND CL,DL
        OR BX,CX
        MOV ES:[BP+02000],BX
        POP ES

        POP BX
        INC BH                  ;VOLGENDE BEELDLIJN
        ADD BP,04000            ;VOLGENDE HERC BEELDLIJN
        IF S ADD BP,08054       ;2*-04000 + DEC. 84
        DEC AH
        JNZ BYTE8LOOP_X_HERC

        POP CX
        POP DI
        POP SI
        TEST CL,31
        JZ RET                  ;RETURN ALS DIT DE LAATSTE ATTR-BYTE WAS VAN
                                ; DEZE REGEL (ZF=1)
        DEC CL
        CMPSB
        JZ RET                  ;TERUG ALS VOLGENDE NIET VERANDERD IS (ZF=1)
        ADD BP,0FEAE            ;= 4*-84 -2
        ADD BX,0F7FF
        PUSH SI
        PUSH DI
        PUSH CX
        PUSH BX
        INC SI
        JMP NEXT_BYTE_X_HERC
        RET



EMULSCRN_X_HERC:
        PUSH CX
        PUSH DI
        INC SI                  ;MAAK GOEDE ADRES

        MOV BX,SI               ;BEREKEN SPECTRUM-ATTR ADRES
        MOV CL,3
        SHR BH,CL
        OR BH,050               ;BX IS NU ATTR ADRES
        mov bp,bx               ;bp=attr

        mov bx,si
        MOV CH,BL               ;CH=X
        INC CL
        SHR BX,CL               ;BX 4 NAAR RECHTS
        AND BL,0FE              ;HAAL LAATSTE BIT VAN X WEG. BX IS NU 2*Y+1024
        MOV CL,CH
        SHL CL,1                ;CX=X*2
        AND CX,0111110XB        ;HOU ALLEEN X-BITS OVER (MAAK CH 0)
        MOV DI,CS:[SCREEN_ADDRESSES_MINUS_1024_X_HERC+BX]
        ADD DI,CX               ;DI IS NU X_HERC ADRES

;De adressen zijn nu berekend; nu worden de waarden opgehaald.

CONTINUE_EMULATING_X_HERC:
        MOV AL,ds:[bp]          ;HAAL ATTR
        XOR AH,AH
        PUSH AX
        MOV BX,OFFSET XLATTAB
        CS:XLATB
        MOV BL,AL
        XOR BH,BH
        SAL BX,1
        MOV DX,CS:[ATTR_TAB+BX]
ATRPOK7 EQU $-2
        POP BX
        SHL BX,1                ;MAAL 2
        MOV AX,CS:[ATTR_TAB+BX] ;HAAL IN AX DE ATTR DATA
ATRPOK8 EQU $-2
        MOV BL,[SI]             ;HAAL DE GRAFISCHE DATA
        MOV ES:[SI],BL          ;ZET GR.DATA IN VIDEO BUFFER
        XOR BH,BH
        SHL BX,1                ;MAAL 2
        PUSH DX                 ;ZET 2E ATTR DATA OP STACK
        MOV DX,CS:[GRAPHIC_TABLE+BX]
        PUSH DX

        DEC SI                  ;MAAK GOEDE ADRES
        MOV CX,DX               ;BEREKEN ATTR/GRAPHIC CGA DATA
        NOT CX
        AND CH,AL
        AND CL,AL
        AND DH,AH
        AND DL,AH
        OR CX,DX
        POP DX                  ;GRAFISCHE DATA
        POP BX                  ;HAAL 2E ATTR DATA TERUG

        PUSH ES                 ;ZET DATA OP HERC SCHERM
        MOV AX,0B000
        MOV ES,AX
        MOV ES:[DI+02000],CX
        MOV CX,DX
        AND CH,BH
        AND CL,BH
        NOT DX
        AND DL,BL
        AND DH,BL
        OR CX,DX
        MOV ES:[DI],CX
        POP ES

        LEA BX,[DI-2]           ;BX IS NIEUW HERC ADR, VOOR LATER
        POP DI
        POP CX
        TEST CL,31
        JZ RET                  ;ERUIT ALS EINDE VD REGEL (OF VID.BUF.)
        DEC CL
        CMPSB
        JZ RET                  ;ERUIT ALS BYTES GELIJK
        PUSH CX
        PUSH DI
        MOV DI,BX
        DEC BP                  ;BP=NIEUW ATTR-ADRES
        INC SI
        JMP CONTINUE_EMULATING_X_HERC
        RET
#endif


SAVE_SCREEN:
        PUSHF
        CLD
        PUSH SI
        PUSH DI
        PUSH DS
        PUSH ES
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        CALL GET_PARM
        JC RET
        MOV AH,3
        INT 010
        MOV CS:CURPOSN,DX
        MOV CX,2000
        REP MOVSW
        POP DX
        POP CX
        POP BX
        POP AX
        POP ES
        POP DS
        POP DI
        POP SI
        POPF
        RET

GET_SCREEN:
        PUSHF
        CLD
        PUSH SI
        PUSH DI
        PUSH DS
        PUSH ES
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        CALL GET_PARM
        JC RET
        MOV DX,CS:CURPOSN
        MOV AH,2
        INT 010
        PUSH ES
        PUSH DS
        POP ES
        POP DS
        XCHG SI,DI
        MOV CX,2000
        REP MOVSW
        POP DX
        POP CX
        POP BX
        POP AX
        POP ES
        POP DS
        POP DI
        POP SI
        POPF
        RET

GET_PARM:
        MOV AH,0F
        INT 010
        MOV CX,0B800
        CMP AL,4
        JB GOTIT
        MOV CH,0B0
        CMP AL,7
        JE GOTIT
        STC
        RET
GOTIT:  MOV DH,BH
        CMP AL,2
        IF AE SHL DH,1
        MOV DL,0
        ADD DX,DX
        ADD DX,DX
        ADD DX,DX
        MOV SI,DX
        LES DI,CS:SCRNBUFFER
        MOV DS,CX
        RET

startup ends


