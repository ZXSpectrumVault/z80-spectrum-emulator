
zxtors232   equ 0   ;if <> 0 zx printer output goes to rs232 channel output
shortprint equ 1


;************************ DISCiPLECheckActive *****************************
DISCiPLECheckActive     proc
;
;**************************************************************************
;       ENTRY:  None
;
;       EXIT:   Base address correct in DISCiPLEDiskBase
;**************************************************************************

        pushf
        push    ax
        push    bx
        mov     al,byte ptr cs:[DISCiPLEDiskNo] ; get active drive no.
        cmp     al,1
        jne     DISCiPLECheckN1
        mov     bx,offset L1772D1Command     ; base address of drive 1
        jmp     DISCiPLECheckOk

DISCiPLECheckN1:
        cmp     al,2
        jne     DISCiPLECheckN2
        mov     bx,offset L1772D2Command     ; base address of drive 2
        jmp     DISCiPLECheckOk

DISCiPLECheckN2:
        mov     bx,0                            ; No Drive!

DISCiPLECheckOk:
        mov     word ptr cs:[DISCiPLEDiskBase],bx
        pop     bx
        pop     ax
        popf
        ret

DISCiPLECheckActive     endp
;******************** END OF PROCEDURE DISCiPLECheckActive ****************




;**************************** L1772OutByte ********************************
L1772OutByte    proc

;**************************************************************************
;
;       ENTRY:  DX = port to output to
;               AL = byte to output
;
;       EXIT:   returns when controller ready for next command byte
;
;**************************************************************************
        out     dx,al                           ; send byte
        call    L1772CheckFree                  ; wait for controller
        ret                                     ; return to calling routine

L1772OutByte    endp
;*******************END OF PROCEDURE L1772OutByte *************************




;**************************** L1772InByte *********************************
L1772InByte     proc

;**************************************************************************
;
;       ENTRY:  DX = port to input from
;
;       EXIT:   returns when controller ready for next command byte
;               AL = input byte
;
;**************************************************************************
        push    cx
        push    dx

L1772InB0:
        mov     cx,4

L1772InB1:
        in      al,61h
        test    al,10h
        jz      L1772InB1
        dec     cx
        cmp     cx,0
        je      L1772InB3

L1772InB2:
        in      al,61h
        test    al,10h
        jne     L1772InB2
        dec     cx
        cmp     cx,0
        jne     L1772InB1

L1772InB3:
        mov     dx,03f4h
        mov     ah,80h

L1772InB4:
        in      al,dx
        test    ah,al
        jnz     L1772InB5
        stc

L1772InB5:
        mov     cx,0
        mov     ah,80
        jc      L1772InB9

L1772InB6:
        in      al,dx
        test    al,40h
        jnz     L1772InB7
        mov     ah,20h
        stc
        jmp     L1772InB10

L1772InB7:
        jcxz    L1772InB8

L1772InB8:
        jcxz    L1772InB9

L1772InB9:
        mov     dx,3f5h
        in      al,dx

L1772InB10:
        pop     dx
        pop     cx
        ret                                     ; return to calling routine

L1772InByte     endp
;*******************END OF PROCEDURE L1772InByte *************************




;**************************** L1772CheckFree ******************************
L1772CheckFree  proc

;**************************************************************************
;
;       ENTRY:  command sent to controller
;
;       EXIT:   controller ready for next command byte
;**************************************************************************
        push    dx
        push    cx
        push    ax
        mov     cx,4

L1772CheckF1:
        in      al,61h
        test    al,10h
        jz      L1772CheckF1
        dec     cx
        cmp     cx,0
        je      L1772CheckF3

L1772CheckF2:
        in      al,61h
        test    al,10h
        jne     L1772CheckF2
        dec     cx
        cmp     cx,0
        jne     L1772CheckF1

L1772CheckF3:
        mov     dx,03f4h
        mov     cx,0                            ; 65536 tries

L1772CheckF4:
        in      al,dx
        test    al,040h
        jz      L1772CheckF5                    ; jump if ok
        loop    L1772CheckF4
        jmp     L1772CheckStartDrive            ; drive stopped so start it

L1772CheckF5:
        mov     cx,0                            ; 65536 tries

L1772CheckF6:
        in      al,dx
        test    al,080h
        jne     L1772CheckFRet                  ; jump if ok
        loop    L1772CheckF6

L1772CheckStartDrive:
        push    dx
        push    ax
        mov     dx,03f2                         ; set port
        mov     al,byte ptr cs:[L1772SeekDrive] ; get drive number
        out     dx,al                           ; start drive motor
        pop     ax
        pop     dx
        jmp     L1772CheckF3
        
L1772CheckFRet:
        pop     ax
        pop     cx
        pop     dx
        ret

L1772CheckFree  endp
;******************* END OF PROCEDURE L1772CheckFree **********************



;****************************  L1772WaitDone ******************************
L1772WaitDone   proc

;**************************************************************************
;
;       ENTRY:  command sent to 1772
;
;       EXIT:   exits when disk comand is complete
;
;**************************************************************************
        push    ds
        push    ax
        push    bx
        push    cx
        mov     ax,040h
        mov     ds,ax
        mov     bx,03eh

L1772WaitD1:
        test    byte ptr ds:[bx],128
        je      L1772WaitD1

        pop     cx
        pop     bx
        pop     ax
        pop     ds
        ret

L1772WaitDone   endp
;********************* END OF PROCEDURE L1772WaitDone *********************



;****************************** L1772Seek *********************************
L1772Seek       proc

;**************************************************************************
;
;       ENTRY:  AH = track to seek to
;               [di+TrackOff]=verify track number
;               DL = 0 - no verify seek, 1 - verify seek
;               AL = drive number
;               BL = delay
;
;       EXIT:   Carry Clear = seek ok
;               Carry Set   = error during seek
;               AH = actual track number under head
;**************************************************************************
        push    bx
        push    cx
        push    dx

        push    ax                              ; store drive number
        mov     byte ptr cs:[DISCiPLEDelay],bl  ; store delay
        cmp     al,0                            ; is it drive A?
        je      L1772SeekA                      ; jump if it is
        mov     al,00100101b                    ; turn drive B motor on
        jmp     L1772Seek1                      ; jump to turn it on

L1772SeekA:
        mov     al,00010100b                    ; turn drive A motor on

L1772Seek1:
        mov     byte ptr cs:[L1772SeekDrive],al
        pop     ax
        push    ax
        mov     dl,al                           ; drive number
        mov     ch,ah                           ; track number
        mov     ah,4h                           ; verify sectors
        mov     al,1                            ; 1 sector
        mov     cl,1                            ; sector 1
        mov     dh,0                            ; head 0
        int     13h                             ; DISK SERVICES

L1772SeekWaitPause:
        push    ds
        push    bx
        mov     ax,040h
        mov     ds,ax
        mov     bx,06ch
        mov     al,byte ptr [bx]                ; get time byte
        add     al,byte ptr cs:[DISCiPLEDelay]  ; wait 3 seconds

L1772SeekWaitPau1:
        cmp     byte ptr [bx],al                ; time up?
        jnz     L1772SeekWaitPau1               ; wait for time up
        pop     bx
        pop     ds

L1772SeekActual:
        mov     dx,03f2h                        ; set port address
        mov     al,byte ptr cs:[L1772SeekDrive] ; drive to turn on
        call    L1772OutByte                    ; send byte
        call    L1772WaitDone                   ; wait for completion
        
L1772Seek12:
        mov     dx,03f5h                        ; set port address
        mov     al,00001111b                    ; SEEK TRACK
        call    L1772Outbyte                    ; send byte
        pop     ax                              ; restore drive number
        push    ax                              ; store track number
        call    L1772Outbyte                    ; send byte
        mov     al,ah                           ; get track to seek to
        call    L1772OutByte                    ; send track number
        call    L1772WaitDone                   ; wait for completion

L1772SeekWaitPause2:
        push    ds
        push    bx
        mov     ax,040h
        mov     ds,ax
        mov     bx,06ch
        mov     al,byte ptr [bx]                ; get time byte
        add     al,byte ptr cs:[DISCiPLEDelay]  ; delay

L1772SeekWaitPau12:
        cmp     byte ptr [bx],al                ; time up?
        jnz     L1772SeekWaitPau12              ; wait for time up
        pop     bx
        pop     ds


        pop     ax                              ; restore track number
        pop     dx                              ; restore verify flag
        push    dx                              ; store verify flag
        cmp     dl,1                            ; verify seek?
        clc                                     ; signal no error
        jne     L1772SeekRet


        push    ax                              ; store track/drive
        mov     dx,03f2h
        mov     al,byte ptr cs:[L1772SeekDrive]
        call    L1772OutByte
        call    L1772WaitDone
        mov     al,01001010b                    ; READ TRACK ID
        mov     dx,03f5h
        call    L1772OutByte                    ; send byte
        pop     ax                              ; restore track/drive
        mov     ah,byte ptr cs:[di+TrackOff]    ; get track number for verify
        push    ax                              ; store track/drive
        call    L1772OutByte                    ; send drive number
        call    L1772WaitDone                   ; wait for completion

        mov     di,offset DISCiPLEBuffer+5120   ; buffer for data
        push    di                              ; store data address
        mov     cx,7                            ; 7 result bytes

L1772Seek3:
        call    L1772InByte                     ; get result byte
        mov     byte ptr cs:[di],al             ; store result
        inc     di
        loop    L1772Seek3                      ; read all bytes
        pop     di                              ; restore data address
        pop     ax                              ; restore track/drive
        test    byte ptr cs:[di],11000000b      ; command successful?
        jne     L1772SeekErr                    ; jump if not
        test    byte ptr cs:[di+1],10110101b    ; command successful?
        jne     L1772SeekErr                    ; jump if not
        test    byte ptr cs:[di+2],01110011b    ; command successful?
        jne     L1772SeekErr                    ; jump if not
        mov     al,byte ptr cs:[di+3]           ; get track number
        xchg    al,ah
        cmp     al,ah                           ; are they equal?
        jne     L1772SeekErr
        clc
        jmp     L1772SeekRet

L1772SeekErr:
        stc                                     ; signal error

L1772SeekRet:
        pushf
        popf
        pop     dx
        pop     cx
        pop     bx
        ret

L1772SeekDrive:
        db      0

L1772Seek0Tries:
        db      0

DISCiPLEDelay:
        db      0

L1772Seek       endp
;*********************** END OF PROCEDURE L1772Seek ***********************



;**************************** DISCiPLEStepIn ******************************

DISCiPLEStepIn  proc

;**************************************************************************
;
;       ENTRY:  AH=command
;               1772 registers set
;
;       EXIT:   1772 registers set
;               correct track selected
;
;**************************************************************************
        push    ax                      ; store command
        mov     al,1                    ; step direction (ie increase track)
        mov     byte ptr cs:DISCiPLEStepDir,al
        pop     ax                      ; restore command
        and     ah,00011111b            ; remove command type
        or      al,00100000b            ; set command type to STEP
        call    DISCiPLEStep            ; call STEP
        ret                             ; return to calling routine

DISCiPLEStepIn  endp

;******************* END OF PROCEDURE DISCiPLEStepIn **********************


;**************************** DISCiPLEStepOut *****************************

DISCiPLEStepOut  proc

;**************************************************************************
;
;       ENTRY:  AH=command
;               1772 registers set
;
;       EXIT:   1772 registers set
;               correct track selected
;
;**************************************************************************
        push    ax                      ; store command
        push    di
        mov     al,0ffh                 ; step direction (ie decrease track)
        mov     byte ptr cs:DISCiPLEStepDir,al
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        cmp     byte ptr cs:[di+TrackOff],0     ; is it track 0?
        jne     DISCiPLEStepOut1        ; jump if not
        mov     al,0
        mov     byte ptr cs:DISCiPLEStepDir,al   ; cannot go further than 0!

DISCiPLEStepOut1:
        pop     di
        pop     ax                      ; restore command
        and     ah,00011111b            ; remove command type
        or      al,00100000b            ; set command type to STEP
        call    DISCiPLEStep            ; call STEP
        ret                             ; return to calling routine

DISCiPLEStepOut  endp

;******************* END OF PROCEDURE DISCiPLEStepOut *********************



;**************************** DISCiPLEStep ********************************

DISCiPLEStep   proc

;**************************************************************************
;
;       ENTRY:  AH=command
;               1772 registers set
;
;       EXIT:   1772 registers set
;               correct track selected
;
;**************************************************************************
        push    ax
        push    bx
        push    cx
        push    dx
        push    ds
        push    es
        push    si
        push    di
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     bx,TypeOff                      ; current disk type offset
        cmp     byte ptr cs:[di+bx],1           ; is it a file?
        je      DISCiPLEStepFile                ; jump if it is
        jmp     near ptr DISCiPLEStepDisk       ; jump if it is a floppy

DISCiPLEStepFile:
        xor     ch,ch
        mov     bx,TotTracksOff                 ; total no. of tracks offset
        mov     cl,byte ptr cs:[di+bx]          ; get no. of tracks
        cmp     cx,0                            ; unformatted?
        jne     DISCiPLEStepF1                  ; jump if formatted

DISCiPLEStepErr:
        or      byte ptr cs:[di+StatusOff],16   ; signal step error
        jmp     DISCiPLEStepRet                 ; return to calling routine

DISCiPLEStepF1:
        mov     bx,TrackInfoOff                 ; offset of track info
        mov     dh,byte ptr cs:[di+CurTkOff]    ; get current track number
        add     dh,byte ptr cs:[DISCiPLEStepDir] ; step in desired direction
        mov     dl,byte ptr cs:[di+SideSelOff]  ; get side number

DISCiPLEStepF2:
        push    ax                              ; store command
        mov     ax,word ptr cs:[di+bx]          ; get track & side number
        cmp     al,dh                           ; correct track?
        je      DISCiPLEStepF4                  ; check side number

DISCiPLEStepF3:
        add     bx,6                            ; move on to next track
        loop    DISCiPLEStepF2                  ; continue for all tracks
        jmp     DISCiPLEStepErr                 ; signal step error

DISCiPLEStepF4:
        cmp     ah,dl                           ; correct side?
        pop     ax                              ; restore command
        jne     DISCiPLEStepF3                  ; jump if not
        mov     byte ptr cs:[di+CurTkOff],dh    ; store new track number
        mov     dx,word ptr cs:[di+bx+2]        ; low bytes of file pointer
        mov     word ptr cs:[di+FilePOff],dx    ; store new file pointer
        mov     dx,word ptr cs:[di+bx+4]        ; high bytes of file pointer
        mov     word ptr cs:[di+FilePOff+2],dx  ; store new file pointer
        test    ah,00010000b                    ; update track register?
        jz      DISCiPLEStepF5                  ; jump if no update
        mov     al,byte ptr cs:[DISCiPLEStepDir] ; get step direction
        add     byte ptr cs:[di+TrackOff],al    ; update track register
        add     byte ptr cs:[di+HWTrackOff],al  ; update hardware track reg.

DISCiPLEStepF5:
        test    ah,00001000b                    ; verify step?
        if z jmp DISCiPLEStepRet                ; jump if no verify

DISCiPLEStepF6:
        mov     bx,word ptr cs:[di+HandleOff]   ; get file handle
        mov     ah,042h                         ; move file pointer
        mov     al,0                            ; to position
        mov     cx,word ptr cs:[di+FilePOff]    ; file pointer
        mov     dx,word ptr cs:[di+FilePOff+2]  ; DX:CX
        int     21h                             ; DOS CALL
        mov     ax,cs
        mov     ds,ax
        mov     dx,offset DISCiPLEBuffer+5120   ; LOAD ADDRESS
        mov     bx,word ptr cs:[di+HandleOff]   ; file handle
        push    dx                              ; store load address
        mov     cx,7                            ; load 7 bytes
        mov     ah,03fh                         ; read file
        int     21h                             ; DOS CALL
        pop     bx                              ; restore load address
        mov     al,byte ptr cs:[di+TrackOff]    ; get track b=number
        cmp     byte ptr cs:[bx],al             ; is it correct track?
        if e jmp DISCiPLEStepRet                ; jump if it is
        jmp     near ptr DISCiPLEStepErr        ; jump to signal step error

DISCiPLEStepDisk:
        mov     al,byte ptr cs:[DISCiPLEStepDir] ; get step direction
        add     byte ptr cs:[di+HWTrackOff],al  ; update hardware track reg
        test    ah,00010000b                    ; update track reg?
        jz      DISCiPLEStepD1                  ; jump if not
        add     byte ptr cs:[di+TrackOff],al    ; update track register
        cmp     byte ptr cs:[di+TrackOff],0     ; track 0?
        jne     DISCiPLEStepD1                  ; jump if not
        or      byte ptr cs:[di+StatusOff],4    ; signal Track 0

DISCiPLEStepD1:
        and     ah,00001000b                    ; keep verify flag
        mov     cl,3
        ror     ah,cl                           ; move verify bit to bit 0
        mov     dl,ah                           ; dl=verify
        mov     ah,byte ptr cs:[di+HWTrackOff]  ; get track to seek to
        mov     al,byte ptr cs:[di+DriveOff]    ; get drive number
        cmp     byte ptr cs:DISCiPLEStepFast,0ff ; fast step?
        je      DISCiPLEStepD2                  ; jump if it is
        mov     bl,2                            ; delay
        call    L1772Seek                       ; seek to track

DISCiPLEStepD2:
        mov     byte ptr cs:[di+TrackOff],ah    ; store track number
        jnc     DISCiPLEStepRet                 ; if no error return
        jmp     near ptr DISCiPLEStepErr        ; signal step error

DISCiPLEStepRet:
        cmp     byte ptr cs:[di+TrackOff],0     ; track 0?
        jne     DISCiPLEStepRet2                ; jump if not
        or      byte ptr cs:[di+StatusOff],4    ; signal track 0

DISCiPLEStepRet2:
        pop     di
        pop     si
        pop     es
        pop     ds
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret

DISCiPLEStepDir:
        db      0                               ; step direction

DISCiPLEStepFast:
        db      0ff                             ; 0ff=fast step

DISCiPLEStep    endp

;******************* END OF PROCEDURE DISCiPLEStep ************************



;************************** DISCiPLEReadAdFor *****************************

DISCiPLEReadAdFor       proc


;**************************************************************************
;
;       ENTRY:  AH=command
;
;       EXIT:   relevant status bits set & command carried out
;
;**************************************************************************
        mov byte cs:disciplebufftrk,0ff      ;Signal buffered track invalid (GL)
        test    ah,00010000b            ; read address/force interrupt
        if z jmp DISCiPLEReadAddr       ; jump if read address
        push    ax
        push    di
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     byte ptr cs:[di+StatusOff],0    ; signal status OK
        cmp     byte ptr cs:[di+TrackOff],0     ; track 0?
        jne     DISCiPLEForce1                  ; jump if not
        or      byte ptr cs:[di+StatusOff],4    ; signal track 0

DISCiPLEForce1:
        push    ax
        push    bx
        push    cx
        push    dx
        push    es
        push    di
        mov     ah,0ff
        mov     byte ptr cs:[DISCiPLEAllowIP],ah
        or      byte ptr cs:[di+StatusOff],2    ; signal index pulse
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     ax,cs
        mov     es,ax
        mov     ax,0201
        mov     ch,byte ptr cs:[di+TrackOff]
        mov     cl,byte ptr cs:[di+SectorOff]
        mov     dh,byte ptr cs:[di+SideSelOff]
        mov     dl,byte ptr cs:[di+DriveOff]
        mov     bx,offset DISCiPLEBuffer+5120
        cmp     cx,0
        jne     DISCiPLEForce20
        mov     cx,0001

DISCiPLEForce20:
        int     013
        jnc     DISCiPLEForce30
        test    ah,080                          ; disk change?
        jz      DISCiPLEForce30                 ; jump if not
        mov     ah,0                            ; reset disk controller
        int     013
        mov     ah,0ff
        mov     byte ptr cs:[DISCiPLEBuffTrk],ah ; signal disk change
        mov     ah,0
        mov     byte ptr cs:[DISCiPLEAllowIP],ah
        

DISCiPLEForce30:
        pop     di
        pop     es
        pop     dx
        pop     cx
        pop     bx
        pop     ax

DISCiPLEForce2:
        pop     di
        pop     ax
        ret

DISCiPLEReadAddr:
        push    di
        push    ax
        push    bx
        push    cx
        push    dx
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        push    di
        mov     al,byte ptr cs:[di+DriveOff]    ; get drive number
        push    ax                              ; store drive number
        cmp     al,0                            ; drive 0?
        je      DISCiPLEReadAddr1               ; jump if it is
        mov     al,00100101b                    ; turn drive motor B on
        jmp     DISCiPLEReadAddr2

DISCiPLEReadAddr1:
        mov     al,00010100b                    ; turn drive motor A on

DISCiPLEReadAddr2:
        mov     byte ptr cs:[L1772SeekDrive],al ; store drive number
        mov     dx,03f2                         ; controller address
        call    L1772OutByte                    ; send byte
        call    L1772WaitDone                   ; wait for completion
        mov     al,01001010b                    ; read track ID
        mov     dx,03f5                         ; command address
        call    L1772OutByte                    ; send command
        pop     ax                              ; restore drive number
        call    L1772OutByte                    ; send byte
        call    L1772WaitDone                   ; wait for completion

        mov     di,offset DISCiPLEBuffer+5120   ; address to store ID
        push    di                              ; store address
        mov     cx,6                            ; 7 bytes to read
        mov     word ptr cs:[DISCiPLEDataLength],cx  ; store number of bytes
        add     cx,1

DISCiPLEReadAddr3:
        call    L1772InByte                     ; get byte
        mov     byte ptr cs:[di],al             ; store byte
        inc     di
        loop    DISCiPLEReadAddr3               ; read all bytes
        pop     di                              ; restore ID address
        add     di,3                            ; point to ID
        mov     word ptr cs:[DISCiPLEDataAddress],di   ;store ID address
        sub     di,3                            ; point to first status byte
        test    byte ptr cs:[di],11000000b      ; command successful?
        jne     DISCiPLEReadAddrErr             ; jump if not
        test    byte ptr cs:[di+1],10110101b    ; command successful?
        jne     DISCiPLEReadAddrErr             ; jump if not
        test    byte ptr cs:[di+2],01110011b    ; command successful?
        jne     DISCiPLEReadAddrErr             ; jump if not

DISCiPLEReadAdForFix:
        mov     ah,byte ptr cs:[di+3]           ; get track number
        pop     di
        mov     byte ptr cs:[di+SectorOff],ah   ; store track number
        mov     byte ptr cs:[di+StatusOff],0    ; signal status OK
        or      byte ptr cs:[di+StatusOff],10100011b
        jmp     DISCiPLEReadAddrRet

DISCiPLEReadAddrErr:
        mov     word ptr cs:[DISCiPLEDataLength],0  ; signal 0 bytes to read
        pop     di
        mov     byte ptr cs:[di+StatusOff],00010000b    ; error

DISCiPLEReadAddrRet:
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        pop     di
        ret

DISCiPLEReadAdFor       endp

;******************** END OF PROCEDURE DISCiPLEReadAdFor ******************






;************************* DISCiPLEReadSec ********************************

DISCiPLEReadSec proc

;**************************************************************************
;
;       ENTRY:  AH=read sector command
;               TrackReg = Track
;               SectorReg = Sector
;               [di+SideSelOff] = Side
;               [di+DriveOff] = Drive number
;               DiscipleBuffTrk : buffered track number, or #ff if invalid
;               BadTrack : 0ff if already tried to load entire buffered track, but no luck
;
;       EXIT:   status register holds read status
;               DISCiPLEDataAddress = address to get data
;               DISCIPLEDataLength = length of data (assumed 512 bytes)
;               DiscipleBuffTrk = buffered track no
;               BadTrack : 0ff if above track no couldn't be loaded completely
;
;Modified to allow for interleave (see also code in disciple.c) (GL)
;
;**************************************************************************
        push    ax
        push    bx
        push    cx
        push    dx
        push    ds
        push    es
        push    di
        push    si
        call    SetInt01E
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     byte ptr cs:[di+StatusOff],0    ; signal ok
        cmp     byte ptr cs:[di+TrackOff],0     ; track 0?
        if z or byte ptr cs:[di+StatusOff],4    ; signal track 0
        cmp     byte ptr cs:[di+TypeOff],1      ; is it a file?
        if z jmp DISCiPLEReadSecFile
        mov     ax,cs
        mov     es,ax
        mov     al,byte ptr cs:[DISCiPLEBuffTrk]; get track no. loaded
        cmp al,0ff
        je disciplereadtrack
        cmp     al,byte ptr cs:[di+TrackOff]    ; track loaded=track wanted?
        jne     disciplereadtrack               ; jump if not
        mov al,cs:[offset disciplebuffside]
        cmp al,cs:[di+SideSelOff]
        jne disciplereadtrack
        cmp byte cs:[offset badtrack],0ff       ; could it be loaded?
        je disciplereadsector
        jmp disciplereadsec1

disciplereadtrack:
        mov byte cs:[offset badtrack],0         ;signal track ok
        mov ch,cs:b[di+TrackOff]                ;get track no.
        mov cs:b[disciplebufftrk],ch            ;store number of buffered track
        mov     dh,byte ptr cs:[di+SideSelOff]  ; DH=Side
        mov cs:b[disciplebuffside],dh
        mov     dl,byte ptr cs:[di+DriveOff]    ; DL=Drive number
        mov cl,1
disciplelooptrack:
        mov bx,4                                ;try 4 times for each sector
discipleloop2track:
        push bx
        mov bh,cl
        xor bl,bl
        add bx,bx
        add bx,offset disciplebuffer-512        ;compute buffer address
        mov ax,0201                             ;read 1 sector
        int 013
        pop bx
        jnc disciplenextsec                     ;jump on no error
        dec bx
        cmp bx,3
        jae discipleloop2track                  ;first try two times
        mov ah,0
        int 013                                 ;reset ctrlr & try again
        test bx
        jne discipleloop2track
        test    ah,080                          ; no disk in drive?
        jz      DISCiPLEReadsector              ; jump if disk present
        mov     ah,0
        mov     byte ptr cs:[DISCiPLEAllowIP],ah  ; keep count to 0!
        mov     byte ptr cs:[di+StatusOff],16
        jmp     DISCiPLEReadSecRet

disciplenextsec:
        add cl,5                                ;1,6,2,7,3,8,4,9,5,10
        cmp cl,10
        jbe disciplelooptrack
        sub cl,9
        cmp cl,6
        jne disciplelooptrack
        jmp disciplereadsec1

disciplereadsector:
        mov cs:b[offset badtrack],0ff           ;signal: bad track
        mov ch,cs:b[di+TrackOff]                ;get track no.
        mov cs:b[disciplebufftrk],ch            ;store number of buffered track
        mov     dh,byte ptr cs:[di+SideSelOff]  ; DH=Side
        mov     dl,byte ptr cs:[di+DriveOff]    ; DL=Drive number
        mov cl,cs:b[di+sectoroff]               ; cl=sector number
        mov bx,4                                ;try 4 times for this sector
discipleloop3track:
        push bx
        mov bh,cl
        xor bl,bl
        add bx,bx
        add bx,offset disciplebuffer-512        ;compute buffer address
        mov ax,0201                             ;read 1 sector
        int 013
        pop bx
        jnc disciplereadsec1                    ;jump on no error
        mov ah,0
        int 013                                 ;reset ctrlr & try again
        dec bx
        jne discipleloop3track
        
DISCiPLEReadSec0:
        or      byte ptr cs:[di+StatusOff],16   ;crc error or similar signal
        jmp     DISCiPLEReadSecRet

DISCiPLEReadSec1:
        mov     bx,512                          ; bytes to be read
        mov     word ptr cs:[DISCiPLEDataLength],bx   ; set bytes to read
        mov     cl,byte ptr cs:[di+SectorOff]   ; get sector number
        mov     ch,0
        dec     cx
        mov     ax,512
        mul     cx                              ; AX=512*(sec-1)
        add     ax,offset DISCiPLEBuffer        ; sector offset within buffer
        mov     word ptr cs:[DISCiPLEDataAddress],ax ; store address
        jmp     DISCiPLEReadSecRet              ; return

DISCiPLEReadSecFile:
        jmp     DISCiPLEReadSecRet              ; not ready ***************

DISCiPLEReadSecRet:
        call    ResetInt01E
        pop     si
        pop     di
        pop     es
        pop     ds
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret

DISCiPLEReadSec endp
;********************** END OF PROCEDURE DISCiPLEReadSec ******************






;*************************** DISCiPLEWriteSec *****************************

DISCiPLEWriteSec        proc

;**************************************************************************
;
;       ENTRY:  AH              = write sector command
;               TrackReg        = Track
;               SecReg          = Sector
;               [di+SideSelOff] = Side
;               [di+DriveOff]   = Drive
;               
;       EXIT:   required parameters set for writing of data
;
;**************************************************************************
        
        push    di
        push    bx
        mov     di,word ptr cs:[DISCiPLEDiskBase]
        mov     byte ptr cs:[di+StatusOff],0            ; signal ok
        cmp     byte ptr cs:[di+TrackOff],0             ; track 0
        if e or byte ptr cs:[di+StatusOff],4            ; signal track 0
        mov     bx,offset DISCiPLEBuffer                ; address to write to
        mov     word ptr cs:[DISCiPLEDataAddress],bx    ; store address
        mov     bx,0200                                 ; assume 512 bytes
        mov     word ptr cs:[DISCiPLEDataLength],bx     ; store length
        mov byte cs:disciplebufftrk,0ff                 ;Signal: read buffer not valid (GL)

DISCiPLEWriteSecRet:
        pop     bx
        pop     di
        ret

DISCiPLEWriteSec        endp

;******************* END OF PROCEDURE DISCiPLEWriteSec ********************




;**************************** ZXPRINTOUT **********************************

;**************************************************************************
;
;       ENTRY:  AH=printer info:-
;               bit 2 low - starts motor
;               bit 1 high - slows the motor
;               bit 7 high - for printing
;               zxprintcount = bytes in buffer
;               zxbitcount = bits in current print byte
;
;       EXIT:   all relevent flags and counts updated
;               IF zxprintcount=256, then buffer sent to printer and
;               buffer count reset to 0
;
;**************************************************************************
ZXPRINTOUT:
        pushf
        test    ah,4                            ; stop motor?
        je      ZXPrintOut1                     ; jump if not
        push    ax
        mov     ax,08000
        mov     byte ptr cs:[ZXMotor],al        ; turn motor off
        mov     word ptr cs:[zxprintcount],ax
        mov     byte ptr cs:[zxcomm],al
        pop     ax

ZXPrintR:
        popf
        retf                                    ; return

ZXPrintOut1:
        mov     byte ptr cs:[zxmotor],0ff

ZXPrintOut2:
        cmp     byte ptr cs:[ZXMotor],0ff       ; motor on?
        jne ZXPrintR                            ; return if not
        cmp     byte ptr cs:[zxcomm],0ff        ; command or data?
        je      ZXPrintOutDo                    ; jump if data
        mov     byte ptr cs:[zxcomm],0ff        ; signal data
        popf
        retf

        
ZXPrintOutDo:
        push    si
        push    bx
        mov     si,offset ZXPrintBuffer
        mov     bl,byte ptr cs:[zxprintcount]
        xor     bh,bh
        push    ax
        shl     ah,1                            ; move bit to carry
        rcl     byte ptr cs:[si+bx],1           ; move bit to dest
        pop     ax
        pop     bx
        pop     si
        ror     byte ptr cs:zxbitcount,1        ; increase bit count
        cmp     byte ptr cs:zxbitcount,128      ; 8 bits transferred?
;        inc     byte ptr cs:zxprintcount
        if ne jmp ZXPRINTOUTRet                   ; jump if not
        inc     byte ptr cs:zxprintcount        ; increase byte count
        cmp     byte ptr cs:zxprintcount,0
        je      ZXPRINTOUTActual                ; jump if 256 bytes (8 lines)
        test    byte ptr cs:zxprintcount,31     ; 32 bytes printed? (1 line)
        if nz jmp ZXPrintOutRet                 ; jump if not
        push    ax
        mov     al,0
        mov     byte ptr cs:[zxcomm],al
        pop     ax
        popf
        retf

ZxPrintOutActual:
;        int 61                                  ; ***** HMc Debug *****
        cmp     byte ptr es:_zxptype,0ff         ; is it epson?
        if e jmp ZXPrintOutEpson                ; jump if it is

ZXPrintOutHP:
        push    ax
        push    dx
        push    cx
        push    bx
        push    ds
        sub word es:zxprinterlinescount,8
        jae ZXPrintOutActualNoFF
        mov ax,es:zxprinterlines
        mov es:zxprinterlinescount,ax
        test ax
        je ZXPrintOutActualNoFF
        push ds
        mov ax,cs
        mov ds,ax
        mov dx,offset ZXHPLasFF
        mov bx,ZXHPLasFFLen
        call ZXPrintData
        pop ds
ZXPrintOutActualNoFF:
        mov     cx,8                            ; 8 rows of pixels
        mov     dx,ZXPrintBuffer                ; start of data
ZXPrintOutActual1:
        push    cx
        push    ds
        push    dx
        mov     ax,cs
        mov     ds,ax
        mov     dx,offset ZXHPLasDat
        mov     bx,ZXHPLen                   ; length of data
        call    ZXPrintData
        pop     dx
        push    dx
        mov     bx,020
        call    ZXPrintData
        mov     dx,offset ZXHPLasDatEnd
        mov     bx,ZXHPLen2
        call    ZXPrintData
        pop     dx
        pop     ds
        pop     cx
        add     dx,020                          ; next block
        loop    ZXPRintOutActual1
        mov     ax,08000
        mov     byte ptr cs:[zxcomm],al         ; next byte is command
        mov     word ptr cs:[ZXprintcount],ax
        pop     ds
        pop     bx
        pop     cx
        pop     dx
        pop     ax

ZXPRINTOUTRet:
        popf
        retf


#if shortprint

zxprintoutepson:
        push ax
        push bx
        push cx
        push dx
        push si
        push ds
        mov ax,cs
        mov ds,ax
        mov dx,offset zxepslinedat
        mov bx,zxepslinelen
        call zxprintdata
        mov si,offset zxprintbuffer
        mov bx,0
        mov cl,080
zxpoe_getbyte:
        test [si+bx],cl
        if nz stc
        rcl al,1
        add bl,32
        jnc zxpoe_getbyte
        call zxprintbyte
        ror cl,1
        adc bl,0
        cmp bl,32
        jne zxpoe_getbyte
        mov dx,offset zxepsdatend
        mov bx,zxepslen2
        call zxprintdata
        mov dx,offset zxepsdatend2
        mov bx,zxepslen3
        call zxprintdata
        mov ax,08000
        mov byte ptr cs:[zxcomm],al
        mov word ptr cs:[zxprintcount],ax
        pop ds
        pop si
        pop dx
        pop cx
        pop bx
        pop ax
        popf
        retf

#else

ZXPrintOutEpson:
        push    ax
        push    bx
        push    cx
        push    dx
        push    si
        push    ds
        mov     ax,cs
        mov     ds,ax
        mov     si,offset ZXPrintBuffer
        mov     cx,8                            ; 8 * 32 = 256 bytes

ZXPrintOutEps1:
        push    cx
        push    si
        mov     dx,offset ZXEpsDat
        mov     bx,ZXEpsLen
        call    ZXPrintData
        pop     si                              ; restore start address
        push    si
        mov     cx,020                          ; 32 bytes to send = 256 bits

ZXPrintOutEps2:
        push    cx
        mov     cx,8                            ; 8 bits per byte
        mov     al,byte ptr [si]

ZXPrintOutEps3:
        push    cx
        push    si
        push    ax
        and al,080
        call zxprintbyte                        ;send one byte per pixel
        pop     ax
        shl al,1                                ;shift left one bit
        pop     si
        pop     cx
        loop    ZXPrintOutEps3
        pop     cx
        inc     si                              ; point to next byte
        loop    ZXPrintOutEps2                  ; print out 32 bytes
        pop     si
        pop     cx
        add     si,020
        mov     dx,offset ZXEpsDatEnd
        mov     bx,ZXEpsLen2
        call    ZXPrintData
        loop    ZXPrintOutEps1
ZXPrintOutEpsonRet:
        mov     dx,offset ZXEpsDatEnd2
        mov     bx,ZXEpsLen3
        call    ZXPrintData
        mov     ax,08000
        mov     byte ptr cs:[zxcomm],al
        mov     word ptr cs:[zxprintcount],ax
        pop     ds
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        popf
        retf

#endif


ZXPRINTCOUNT:
        db      0                       ; bytes sent

ZXBITCOUNT:
        db      080                     ; bits sent (must be just after zxprintcount)

ZXMotor:
        db      0                       ; 0ff=on

ZXComm: db      0                       ; 0ff=data now sent

ZXHPLasFF:
        db 27,'&l0H'                    ; form feed
ZXHPLasFFLen    equ $-ZXHPLasFF

ZXHPLasDat:
          db  27,'*b0Y'
          db  27,'*t75R'                ; 75 dpi
          db  27,'*r1A'                 ; left hand side of page
          db  27,'*b32W'                ; 32 bytes of data

ZXHPLasDatEnd:

          db  27,'*rbC'                 ; end of graphic data

ZXHPLasDatEnd2:

ZXHPLen equ     ZXHPLasDatEnd-ZXHPLasDat
ZXHPLen2  equ   ZXHPLasDatEnd2-ZXHPLasDatEnd

zxepslinedat:
          db 27,'3',24                  ; 8 * 3/216 inch line spacing GL
          db 27,'K',0,1                 ; 256 bytes of data to follow

ZXEpsDat: db    27,'3',3                ; 3/216 inch line spacing
          db    27,'K',0,1              ; 256 bytes of data to follow

ZXEpsDatEnd:
          db    13,10                   ; move on to next line

ZXEpsDatEnd2:
          db    27,'3',36               ; 1/6 inch line spacing

ZXEpsDatEnd3:

zxepslinelen equ zxepsdat-zxepslinedat
ZXEpsLen  equ   ZXEpsDatEnd-ZXEpsDat
ZXEpsLen2 equ   ZXEpsDatEnd2-ZXEpsDatEnd
ZXEpsLen3 equ   ZXEpsDatEnd3-ZXEpsDatEnd2

ZXPrintBuffer:
        db 256 dup (0)          ; print buffer

;*********************** END OF PROCEDURE ZXPRINTOUT **********************


zxprintbyte:

#if zxtors232

        call far write_savereg_far
        ret

#else

        push ax
        push dx
        mov ah,es:zxprstatus
        test ah,8
        jne zxprintbyte_finished
        test ah,080
        je zxprintbyte_finished
        mov dx,es:zxprint
        mov ah,2
        int 017
        test ah,128
        je zxprintbyte_wait
zxprintbyte0:
        xor ah,ah
        int 017
zxprintbyte_finished:
        pop dx
        pop ax
        ret

zxprintbyte_wait:
        push word es:_count200hz
        mov word es:_count200hz,0
zxpbw:
        cmp es:_count200hz,1000
        jae zxprinter_notready
        mov ah,2
        mov dx,es:zxprint
        int 017
        test ah,128
        je zxpbw
        pop word es:_count200hz
        jmp zxprintbyte0

zxprinter_notready:
        pop word es:_count200hz
        mov dx,es:zxprint
        mov ah,2
        int 017
        mov es:zxprstatus,ah
        pop dx
        pop ax
        ret

#endif


ZXPRINTData     proc

#if zxtors232

        push dx
        push bx
        mov bx,dx
        mov al,cs:[bx]
        call far write_savereg_far
        pop bx
        pop dx

#else

        push    bx
        push    dx

ZXPrintDataWait:
        push    ax
        push    bx
        push    dx
        mov     ah,2
        mov     dx,es:zxprint
        int     017
        test    ah,128
        pop     dx
        pop     bx
        pop     ax
        je      ZXPrintDataWait

ZXPrintDataNoWait:
        mov     bx,dx
        mov     al,cs:[bx]
        xor ah,ah
        mov dx,es:zxprint
        int 017
        pop     dx
        pop     bx

#endif

        dec     bx
        inc     dx
        cmp     bx,0
        jne     ZXPRINTData
        ret
ZXPRINTData     endp




;************************* DATA AREA **************************************
                                
DISCiPLEBuffer:
        db      6144 dup (0)                    ; Disk buffer (6 Kb)

DISCiPLED1Trackinfo:
        db      1050 dup (0)                    ; Track info of Disk1

DISCiPLED2Trackinfo:
        db      1050 dup (0)                    ; Track info of Disk2

;*
;* From DISCiPLEBuffer onwards there should be at least 8000 bytes of
;* workspace, which is used during startup to hold the Z80.INI file.
;*

DISCiPLEBuffTrk:
        db      0ff                          ; Holds Track Number loaded

disciplebuffside:                           ;holds side # of track buffered
        db 0

BadTrack:
        db      0                            ;0ff if bufftrk could not be wholly loaded

DISCiPLEDataAddress:
        dw      0                            ; address of DATA of read/write

DISCiPLEDataLength:
        dw      0                            ; bytes of DATA to read/write

_DISCiPLEDiskNo:                                ; 'C' label
DISCiPLEDiskNo:
        db      1                               ; 1 or 2 (drive number)

DISCiPLEDiskBase:                               ; Base address of drive data
        dw      L1772D1Command                  ; of active drive

L1772D1Command:
        db      0                               ; Command Register Disk1

L1772D1Status:
        db      0                               ; Status Register Disk1

L1772D1Track:
        db      0                               ; Track Register Disk1

L1772D1HWTrack:
        db      0                               ; Hardware Track Disk1

L1772D1Sector:
        db      0                               ; Sector Register Disk1

L1772D1Data:
        db      0                               ; Data Register Disk1

L1772D1Gap:
        db      0                               ; 0 = Gap, 0FF = Data  Disk1

_DISCD1FileName:                                ; 'C' label
DISCiPLED1Filename:
        db      8 dup (32)                      ; FileName of Disk1
        db      '.DSK'
        db      0                               ; filename terminator

DISCiPLED1WriteProtect:
        db      0                               ; write protect 

_DISCD1Type:                                    ; 'C' label
DISCiPLED1Type:
        db      0FFh                            ; 1=File, 0FF=Floppy

_DISCD1Drive:                                   ; 'C' label
DISCiPLED1Drive:
        db      0                               ; Hardware drive No.

DISCiPLED1Handle:
        dw      0                               ; File Handle of Disk1

DISCiPLED1FilePointer:
        dd      0                               ; File position of Disk1

DISCiPLED1TotTracks:
        db      160                             ; Total No of tracks

DISCiPLED1Tracks:
        db      80                              ; No of Tracks

DISCiPLED1Sides:
        db      2                               ; No of sides

DISCiPLED1Density:
        db      0                               ; 0=DD 0FF=SD  Disk1

DISCiPLED1CurTk:
        db      0                               ; current track no.

DISCiPLED1SideSel:
        db      0                               ; selected side number

DISCiPLED1Reserved:
        db      4 dup (0)                       ; (may be used later)

L1772D2Command:
        db      0                               ; Command Register Disk2

L1772D2Status:
        db      0                               ; Status Register Disk2

L1772D2Track:
        db      0                               ; Track Register Disk2

L1772D2HWTrack:
        db      0                               ; Hardware Track Disk2

L1772D2Sector:
        db      0                               ; Sector Register Disk2

L1772D2Data:
        db      0                               ; Data Register Disk2

L1772D2Gap:
        db      0                               ; 0 = Gap, 0FF = Data  Disk2


_DISCD2Filename:                                ; 'C' label
DISCiPLED2Filename:
        db      8 dup (32)                      ; FileName of Disk2
        db      '.DSK'
        db      0                               ; filename terminator

DISCiPLED2WriteProtect:
        db      0                               ; write protect 

_DISCD2Type:                                    ; 'C' label
DISCiPLED2Type:
        db      0ff                             ; 1=File, 0FF=Floppy

_DISCD2Drive:                                   ; 'C' label
DISCiPLED2Drive:
        db      1                               ; Hardware drive No.

DISCiPLED2Handle:
        dw      0                               ; File Handle of Disk2

DISCiPLED2FilePointer:
        dd      0                               ; File position of Disk2

DISCiPLED2TotTracks:
        db      160                             ; Total No of tracks

DISCiPLED2Tracks:
        db      80                              ; No of Tracks

DISCiPLED2Sides:
        db      2                               ; No of sides

DISCiPLED2Density:
        db      0                               ; 0=DD 0FF=SD  Disk2

DISCiPLED2CurTk:
        db      0                               ; current track no.

DISCiPLED2SideSel:
        db      0                               ; selected side number

DISCiPLED2Reserved:
        db      4 dup (0)                       ; (may be used later)


      CommandOff        equ     0
      StatusOff         equ     L1772D1Status-L1772D1Command
      TrackOff          equ     L1772D1Track-L1772D1Command
      HWTrackOff        equ     L1772D1HWTrack-L1772D1Command
      SectorOff         equ     L1772D1Sector-L1772D1Command
      DataOff           equ     L1772D1Data-L1772D1Command
      GapOff            equ     L1772D1Gap-L1772D1Command
      TotTracksOff      equ     DISCiPLED1TotTracks-L1772D1Command
      TracksOff         equ     DISCiPLED1Tracks-L1772D1Command
      SidesOff          equ     DISCiPLED1Sides-L1772D1Command
      DensityOff        equ     DISCiPLED1Density-L1772D1Command
      FileNameOff       equ     DISCiPLED1Filename-L1772D1Command
      WriteProtOff      equ     DISCiPLED1WriteProtect-L1772D1Command
      TypeOff           equ     DISCiPLED1Type-L1772D1Command
      DriveOff          equ     DISCiPLED1Drive-L1772D1Command
      HandleOff         equ     DISCiPLED1Handle-L1772D1Command
      FilePOff          equ     DISCiPLED1FilePointer-L1772D1Command
      TrackinfoOff      equ     DISCiPLED1Trackinfo-L1772D1Command
      CurTkOff          equ     DISCiPLED1CurTk-L1772D1Command
      SideSelOff        equ     DISCiPLED1SideSel-L1772D1Command





;************************** END OF SUBROUTINES ****************************

DISCIP     ends

end  Main

