;
;   This file is part of the registered Spectrum emulator package 'Z80'
;   version 2.01, and may not be distributed.  You may use this source for
;   other PC based Spectrum or Z80 emulators only after permission.  It is
;   however permitted to use this source file or parts thereof for Spectrum
;   or Z80 emulators on non-PC based machines, provided that the source is
;   acknowledged.
;
;                                                       Gerton Lunter, 3/5/93

startup segment para public

KR25:   TEST BYTE CS:BREAK              ;Eerste label van deze file!
        JNZ RET
        MOV BYTE CS:C_ACTIVE,0FF
        MOV BYTE CS:C_ACTION_CODE,0FF   ;ACTIVERING: EEN DRUK OP 'F10'
        RET

KR20:   TEST BYTE CS:BREAK
        JNZ RET
        MOV BYTE CS:C_ACTIVE,0FF
        test cs:b[in2_tab+7],2
        jnz kr20_1
        MOV BYTE CS:C_ACTION_CODE,0F8   ;ACTIVERING: EEN DRUK OP 'F1' (HELP)
        ret
kr20_1:
        mov byte cs:c_action_code,0ed   ;Alt-F1
        RET

KR21:   TEST BYTE CS:BREAK
        JNZ RET
        MOV BYTE CS:C_ACTIVE,0FF
        MOV BYTE CS:C_ACTION_CODE,0F7   ;ACTIVERING: EEN DRUK OP 'F2' (SAVE)
        RET

KR22:   TEST BYTE CS:BREAK
        JNZ RET
        MOV BYTE CS:C_ACTIVE,0FF
        MOV BYTE CS:C_ACTION_CODE,0F6   ;ACTIVERING: EEN DRUK OP 'F3' (LOAD)
        RET

KR23:   TEST BYTE CS:BREAK
        JNZ RET
        MOV BYTE CS:C_ACTIVE,0FF
        MOV BYTE CS:C_ACTION_CODE,0F5   ;ACTIVERING: EEN DRUK OP 'F4' (JOYSTICK)
        RET

KR24:   TEST byte CS:BREAK,0ff          ;F5: NMI / reset
        JNZ RET
        test cs:b[in2_tab+7],2
        mov al,080                      ;reset
        jnz kr24_1
        mov al,0ff                      ;nmi
        cmp byte cs:rommod,2
        ja ret                          ;in 128 mode, nmi is useless
kr24_1:
        MOV byte CS:NMI,al
        and cs:b[in2_tab+7],0fd         ;to let samram think symshift is up
        RET

kr26:   test byte cs:break
        jnz ret
        MOV BYTE CS:C_ACTIVE,0FF
        MOV BYTE CS:C_ACTION_CODE,0F4   ;ACTIVERING: EEN DRUK OP 'F6' (real mode)
        ret

KR27:   TEST BYTE CS:BREAK
        JNZ RET
        MOV BYTE CS:C_ACTIVE,0FF
        MOV BYTE CS:C_ACTION_CODE,0F1   ;ACTIVERING: EEN DRUK OP 'F7' (tape)
        RET

kr28:   test byte cs:break
        jnz ret
        mov byte cs:c_active,0ff
        mov byte cs:c_action_code,0f0   ;activering: druk op f8 (microdrive)
        ret

kr29:   test byte cs:break
        jnz ret
        mov byte cs:c_active,0ff
        mov byte cs:c_action_code,0ee   ;activation: f9 (mode change)
        ret


;Flag om dubbele aanroep ENTER_C te voorkomen (kan gebeuren bij leesfout in
; routine DISK_READBLOCK, in Z80.8, als READ_RS_READY wordt aangeroepen
; vanuit GET_C_VARS)

DOUBLEC         DB 0
DOUBLEC_TRAPADR DW ?
DOUBLEC_TRAPSEG DW ?

NODOUBLEC:
        MOV CS:BYTE VALUE,0             ;ABORT
        MOV AX,CS:DOUBLEC_TRAPADR
        MOV CS:TRAPADR,AX
        MOV AX,CS:DOUBLEC_TRAPSEG
        MOV CS:TRAPSEG,AX
        POPF
        JMP CALL_C_RETURN               ;ZIE Z80.8

ENTER_C:
        PUSHF
        CMP CS:DOUBLEC,0
        JNZ NODOUBLEC
        CALL SAVE_REGS
        POPF
        STI
        PUSHF
        PUSH BX
        PUSH DS
        PUSH ES
        MOV CS:DOUBLEC,1                ;MELD 'C BEZIG'
        MOV AX,CS:TRAPADR
        MOV CS:DOUBLEC_TRAPADR,AX
        MOV AX,CS:TRAPSEG
        MOV CS:DOUBLEC_TRAPSEG,AX       ;SLA OP TER PREVENTIE DUBB. AANROEP
        CALL UNINSTALL_COM              ;ZET DTR ETC. UIT, GEEN IRUPTS MEER
        in al,021                       ;Zet timer irpt aan
        and al,0fe
        out 021,al
        CMP CS:BYTE MODFLG,0
        IF Z CALL VIDEO_UPDATE          ;ZET LAATSTE VERANDERINGEN OP SCHERM
        CLI                             ; MAAR NIET ALS IN REAL MODE
        XOR AX,AX
        MOV ES,AX
;        mov ax,cs:kstate
;        and ax,0f0
;        xchg ax,es:w[0417]
;        mov cs:kstate,ax
;        call set_kbd_leds
        and es:w[0417],0fcf0            ;reset shift/alt/ctrl state
        PUSH ES:[0D*4]
        PUSH ES:[0D*4+2]
        PUSH ES:[32]
        PUSH ES:[34]
        PUSH ES:[36]
        PUSH ES:[38]
        PUSH ES:[44]
        PUSH ES:[46]
        PUSH ES:[48]
        PUSH ES:[50]
        MOV AL,0FF
        OUT 040,AL
        OUT 040,AL
        PUSH ES:[108]
        PUSH ES:[110]                   ;BEWAAR EIGEN CTRL-BREAK HANDLER
        CALL GET_VECTORS                ;ZET OORSPR. IRUPT VECTRS. TERUG
        POP ES:[110]
        POP ES:[108]                    ;ZET EIGEN CTRL-BRK HANDLER TERUG
        STI
        CALL GET_C_VARS
        CALL COMPUTE_RRBIT7
        IN AL,061
        AND AL,011111100XB
        OUT 061,AL                      ;EVT PIEP UIT
        call adlib_quiet
        xor ax,ax
        xchg AL,CS:C_ACTION_CODE
        push ax
;        cmp al,0fd                      ;in 0 crash
;        jnz noin0crash
;        mov di,cs:temp_pc
;        mov cs:rpc,di
;noin0crash:
        CALL FAR _ENTRY                 ;ROEP 'C' AAN (ACTION CODE OP STACK)
        MOV CS:VALUE,AX                 ;BEWAAR TERUGGEGEVEN WAARDE (see call_c)
        POP AX                          ;CLEAR STACK
        MOV AL,1                        ;ZET BIEPER AAN/UIT
        OUT 042,AL                      ;pitch
        OUT 042,AL
        IN AL,061
        MOV AH,CS:[IN31TAB+6]           ;0 OF 255 (NA RESP OUT 31,12 EN 13)
        cmp byte cs:rommod,2                 ;samram?
        if nz xor ah,ah                 ;no, then keep quiet.
        NOT AH
        OR AH,CS:SILENCE
        NOT AH
        AND AX,0000001111111100XB
        OR AL,AH
        OUT 061,AL                      ;EVT PIEP WEER AAN
        call adlib_turnon
        cmp byte cs:spctel,0
        if nz mov byte cs:[offset in_tab+7],0fe     ;space
        CALL SAVE_C_VARS
        CLI
        cmp byte cs:winkey,0
        jne no_tim_inst_2
        MOV AX,CS:ADDNUM
        OUT 040,AL
        MOV AL,AH
        OUT 040,AL
no_tim_inst_2:
        XOR AX,AX
        MOV ES,AX
;        mov ax,cs:kstate
;        and ax,0f0
;        xchg ax,es:w[0417]
;        mov cs:kstate,ax
;        call set_kbd_leds
        POP ES:[50]
        POP ES:[48]
        POP ES:[46]
        POP ES:[44]
        POP ES:[38]                     ;ZET EIGEN VECTORS TERUG
        POP ES:[36]
        POP ES:[34]
        POP ES:[32]
        POP ES:[0D*4+2]
        POP ES:[0D*4]
        STI
        CALL INSTALL_COM
        CMP BYTE CS:MODFLG,0
        JE C_NOREAL
        cmp byte cs:iff,0
        jne c_noreal
        IN AL,021
        OR AL,1
        OUT 021,AL
C_NOREAL:
        POP ES
        POP DS
        POP BX
        mov al,byte cs:maxtel
        dec al
        mov byte cs:inttel,al           ;next interrupt: trigger
        push cs
        call _pauze
        MOV CS:DOUBLEC,0                ;and now interrupts are allowed again
        CALL GET_REGS
        CALL IMMEDIATE_NMI
        POPF
        JMP CS:D[TRAPADR]               ;TERUG NAAR SPEC EMULATOR



COMPUTE_RRBIT7:
        PUSH AX
        MOV AL,CS:NEWBOR
        AND AL,7
        SHL AL,1
        MOV AH,CS:RR_BIT7
        AND AH,1
        OR AL,AH
        MOV AH,CS:B[OFFSET IN31TAB+1]   ;0FF ALS SAMRAM UIT
        NOT AH
        cmp byte cs:rommod,2
        if nz xor ah,ah
        AND AH,010000XB
        OR AL,AH
        MOV CS:RR_BIT7,AL
        POP AX
        RET

STRC MACRO
        STRUC [BP]
        DW ?
        DD ?
#EM

ENTR MACRO
        PUSH DS
        PUSH ES
        PUSH DI
        PUSH SI
#EM

LEAV MACRO
        POP SI
        POP DI
        POP ES
        POP DS
        POP BP
        RETF
#EM

;
;void printchar (x,y,ch)
;int    x,y;
;char   ch;
;
_PRINTCHAR:
        PUSH BP
        MOV BP,SP

        STRC
XCOORD  DW ?
YCOORD  DW ?
PRCHAR  DW ?
        ENDS

        ENTR
        MOV DX,PRCHAR   ;BEREKEN IN DS:SI ADRES VAN KARAKTER
        MOV SI,DX
        AND SI,07F
        SHL SI,1
        SHL SI,1
        SHL SI,1
        CMP SI,9*8
        JA USE_SPECTRUM_CHARSET
        ADD SI,CHARSET-8
        PUSH CS
        POP DS
        JMP SHORT PRINT_IT
USE_SPECTRUM_CHARSET:
        ADD SI,offset specchars
        push cs
        pop ds
PRINT_IT:
        CLD
        MOV AL,CS:GMOD
        OR AL,AL        ;TEST OP CGA
        IF Z JMP CGA_PRNT
        CMP AL,1        ;TEST OP HERCULES
        IF Z JMP HERC_PRNT
        CMP AL,2        ;TEST OP XTD_HERCULES
        IF Z JMP X_HERC_PRNT
        CMP AL,4
        IF Z JMP EGA_PRNT
        CMP AL,3
        IF Z JMP PLANT_PRNT
        cmp al,5
        if z jmp vga_prnt

EXIT_PRCH:              ;EINDE ROUTINE
        LEAV

CHARSET:
        db 0,0,0,3,4,8,8,8              ;© (1)
        DB 0,0,0,255,0,0,0,0            ;Ä (2)
        db 0,0,0,224,16,8,8,8           ;ª (3)
        DB 8,8,8,8,8,8,8,8              ;³ (4)
        db 8,8,4,3,0,0,0,0              ;À (5)
        db 8,8,16,224,0,0,0,0           ;Ù (6)
        DB 0,16,16,16,84,56,16,0        ;pijltje naar beneden (7)
        db 0,0,16,32,126,32,16,0        ;pijltje naar links (8)
        db 0,0,8,4,126,4,8,0            ;pijltje naar rechts (9)

CGA_PRNT:
        MOV AX,0B800
        MOV ES,AX
        MOV AX,YCOORD
        MOV BX,80*2
        PUSH DX
        MUL BX
        POP DX
        ADD AX,XCOORD
        SHL AX,1
        MOV DI,AX
        MOV CX,8
CGA_PRNT_LOOP:
        LODSB
        MOV BL,AL
        XOR BH,BH
        SHL BX,1
        MOV AX,CS:[GRAPHIC_TABLE+BX]
        TEST DL,080
        IF NZ NOT AX
        STOSW
        ADD DI,02000-2
        CMP DI,16384
        IF AE ADD DI,80-04000
        LOOP CGA_PRNT_LOOP
        JMP EXIT_PRCH

HERC_PRNT:
        MOV AX,0B000
        MOV ES,AX
        MOV AX,YCOORD
        MOV BX,90*2
        PUSH DX
        MUL BX
        POP DX
        ADD AX,XCOORD
        SHL AX,1
        MOV DI,AX
        MOV CX,8
HERC_PRNT_LOOP:
        LODSB
        MOV BL,AL
        XOR BH,BH
        SHL BX,1
        MOV AX,CS:[GRAPHIC_TABLE+BX]
        TEST DL,080
        IF NZ NOT AX
        STOSW
        ADD DI,02000-2
        STOSW
        ADD DI,02000-2
        IF S ADD DI,90-08000
        LOOP HERC_PRNT_LOOP
        JMP EXIT_PRCH

X_HERC_PRNT:
        MOV AX,0B000
        MOV ES,AX
        MOV AX,YCOORD
        MOV BX,84*2
        PUSH DX
        MUL BX
        POP DX
        ADD AX,XCOORD
        SHL AX,1
        MOV DI,AX
        MOV CX,8
X_HERC_PRNT_LOOP:
        LODSB
        MOV BL,AL
        XOR BH,BH
        SHL BX,1
        MOV AX,CS:[GRAPHIC_TABLE+BX]
        TEST DL,080
        IF NZ NOT AX
        STOSW
        ADD DI,02000-2
        STOSW
        ADD DI,02000-2
        IF S ADD DI,84-08000
        LOOP X_HERC_PRNT_LOOP
        JMP EXIT_PRCH

EGA_PRNT:
        MOV AX,0A000
        MOV ES,AX
        MOV AX,YCOORD
        MOV BX,40*8
        PUSH DX
        MUL BX
        POP BX
        ADD AX,XCOORD
        MOV DI,AX
        MOV CX,8
        MOV DX,03CE
        MOV AX,0205
        OUT DX,AX
        MOV AX,3
        OUT DX,AX
EGA_PRNT_LOOP:
        MOV AX,0FF08
        OUT DX,AX
        MOV ES:B[DI],1                  ;MAAK BLAUW (voor versie 1.40 zwart)
        MOV AH,8
        LODSB
        TEST BL,080
        IF NZ NOT AL
        XCHG AL,AH
        OUT DX,AX
        mov al,7
        xchg ES:B[DI],al                ;WIT
        ADD DI,40
        LOOP EGA_PRNT_LOOP
        MOV AX,0FF08
        OUT DX,AX
        MOV AX,5
        OUT DX,AX
        JMP EXIT_PRCH

PLANT_PRNT:
        MOV AX,0B800
        MOV ES,AX
        MOV AX,YCOORD
        MOV BX,80*2
        PUSH DX
        MUL BX
        POP DX
        ADD AX,XCOORD
        ADD AX,AX
        MOV DI,AX
        MOV CX,8
PLANT_PRNT_LOOP:
        LODSB
        MOV BL,AL
        XOR BH,BH
        SHL BX,1
        MOV AX,CS:[GRAPHIC_TABLE+BX]
        TEST DL,080
        IF NZ NOT AX
        STOSW
        AND AX,0AAAA
        MOV ES:[DI-2+04000],AX
        ADD DI,-2+02000
        CMP DI,04000
        IF AE ADD DI,80-04000
        LOOP PLANT_PRNT_LOOP
        JMP EXIT_PRCH

vga_prnt:
        mov ax,0b800
        mov es,ax
        mov ax,ycoord
        push dx
        mov dx,640
        mul dx
        sub ax,320
        mov dx,xcoord
        add ax,dx
        add ax,dx
        mov di,ax
        mov ah,01f                      ;Bright white on nonbright blue
        pop dx
        mov cx,8
vga_prntloop:
        lodsb
        test dl,080
        if nz not al
        stosw
        add di,78
        loop vga_prntloop
        jmp exit_prch


;
;void update_video(border)
;int border
;
_UPDATE_VIDEO:
        PUSH BP
        mov bp,sp

        strc
border  dw ?
        ends

        ENTR
        MOV DS,CS:SPECSEG
        MOV ES,CS:VIDBUFSEG

        cmp byte cs:rommod,3
        jb at_4000
        test byte cs:hstate,8           ;Is the screen at page 7?
        je at_4000                      ;Nope, page 5 is (fixed at 4000)
        mov al,cs:[ramstate+3]
        push ax
        mov ax,0300
        call swap_mem                   ;Update possible internal buffer
        pop ax
        mov ah,3
        call swap_mem                   ;restore bank 3 again
        mov ax,010a
        call swap_mem                   ;swap in bank 7 at 04000
at_4000:
        MOV BX,16384
        MOV CX,6912
ALTER_ATTR:
        MOV AL,[BX]
        INC AL
        MOV ES:[BX],AL
        INC BX
        LOOP ALTER_ATTR
        mov ax,0108
        call swap_mem                   ;restore bank 1 to default
        mov ax,border
        mov ah,byte cs:newbor
        push ax
        cmp al,8
        if b mov ah,al
        mov byte cs:newbor,ah
        MOV BYTE CS:BORCLR,0FF          ;NIET BESTAANDE BORDER COLOUR
        CALL VIDEO_UPDATE               ;DI EN SI WORDEN BEWAARD
        pop ax
        mov byte cs:newbor,ah
        cmp byte cs:gmod,5              ;vga
        jnz updvid__end
        mov ax,0b800
        mov es,ax
        mov di,4*40*2+4*2+32*2
        mov cx,195
        cld
        mov ax,08800
restore_border:
        stosw
        stosw
        stosw
        stosw
        stosw
        stosw
        stosw
        stosw
        add di,64
        loop restore_border
updvid__end:
        leav

;
;void init_emulator(void)
;
_INIT_EMULATOR:
        PUSH BP
        ENTR
        MOV DS,CS:SPECSEG
        CALL INIT_EMULATOR
        MOV CS:C_ACTIVE,0
        CLI
        MOV AL,0FF
        OUT 040,AL
        OUT 040,AL
        STI
        LEAV

;
;void install_all(void)
;
_INSTALL_ALL:
        PUSH BP
        ENTR
        CALL SAVE_C_VARS
        MOV DS,CS:SPECSEG
        CALL HOESNEL
        CALL RREG_INST
        CALL LDIR_INST
        CALL SILENCE_INST
        LEAV

;
;int open_file(name,access_code)
;char   *name;
;char   access_code;
;
_OPEN_FILE:
        PUSH BP
        MOV BP,SP

        STRC
NAAM    DD ?
ACCESS  DW ?
        ENDS

        ENTR
        MOV AX,ACCESS
        MOV AH,03D
        LDS DX,NAAM
        INT 021
        IF C MOV AX,0FFFF
        LEAV

;
;int creat_file(name)
;char *name;
;
_CREAT_FILE:
        PUSH BP
        MOV BP,SP

        STRC
NAAM    DD ?
        ENDS

        ENTR
        MOV AH,03C
        LDS DX,NAAM
        MOV CX,32
        INT 021
        IF C MOV AX,0FFFF
        LEAV

;
;int close_file(handle)
;int    handle;
;
_CLOSE_FILE:
        PUSH BP
        MOV BP,SP

        STRC
HANDLE  DW ?
        ENDS

        ENTR
        MOV BX,HANDLE
        MOV AH,03E
        INT 021
        MOV AX,0
        IF NC DEC AX
        LEAV

;
;int read_file(handle,pointer,bytes)
;int    handle;
;char   *pointer;
;int    bytes;
;
_READ_FILE:
        PUSH BP
        MOV BP,SP

        STRC
HANDLE  DW ?
POINTR  DD ?
BYTES   DW ?
        ENDS

        ENTR
        MOV AH,03F
        MOV BX,HANDLE
        MOV CX,BYTES
        LDS DX,POINTR
        INT 021
        IF C XOR AX,AX
        LEAV

;
;int write_file(handle,pointer,bytes)
;int    handle;
;char   *pointer;
;int    bytes;
;
_WRITE_FILE:
        PUSH BP
        MOV BP,SP

        STRC
HANDLE  DW ?
POINTR  DD ?
BYTES   DW ?
        ENDS

        ENTR
        MOV AH,040
        MOV BX,HANDLE
        MOV CX,BYTES
        LDS DX,POINTR
        INT 021
        IF NC CMP AX,BYTES
        IF NC MOV AX,0FFFF
        IF C XOR AX,AX
        LEAV

;
;int getkey(void)
;
_GETKEY:
        PUSH BP
        ENTR
        MOV AH,1
        INT 016
        MOV AL,0
        JZ nochar_releasetime
        XOR AH,AH
        INT 016
        TEST AL,AL
        JNZ NORML_CHAR
        MOV AL,AH
        MOV AH,1
        JMP SHORT getkey_extended
NORML_CHAR:
        XOR AH,AH
getkey_extended:
        LEAV
nochar_releasetime:
        cmp byte cs:winkey,0
        jz norml_char
        mov ax,01680
        int 02f
        xor ax,ax
        jmp getkey_extended


;
;void exit_emulator(void)
;
_EXIT_EMULATOR:
        JMP END_SPECTR

;
;void beep(void)
;
_BEEP:
        PUSH BP
        ENTR
        MOV AL,2
        OUT 042,AL
        OUT 042,AL
        IN AL,061
        PUSH AX
        OR AL,3
        OUT 061,AL
        push cs
        call _pauze
        push cs
        call _pauze
        push cs
        call _pauze
        POP AX
        AND AL,011111100XB
        OUT 061,AL
        LEAV

;
;void pauze(void)
;
_pauze:
        cli
        in al,040
        in al,040
        mov bl,al
        sti
wait182:
        cli
        in al,040
        in al,040
        sti
        cmp al,bl
        mov bl,al
        jbe wait182
        retf

PAR_BLK:
        DW 0                    ;SEGMENT ADRES ENV. BLOK, 0=KOPIE V.H. OUDE
        DW OFFSET COMMAND_TAIL
        DW SEG COMMAND_TAIL
        DD -1                   ;POINTER NAAR FCB1
        DD -1                   ;POINTER NAAR FCB2

COMMAND_TAIL:
        DB 0,0D

COMSPEC:        DB "COMSPEC",0
SAVED_SS        DW ?
SAVED_SP        DW ?

;
;int shell_flushbuf(void)
;
_SHELL_FLUSHBUF:
        PUSH BP
        ENTR
        CALL SHELL_FLUSHBUF
        LEAV

;
;int shell(void)
;
_SHELL:
        PUSH BP
        ENTR
        MOV DS,CS:PROGSEG
        MOV DS,[02C]            ;DS:0 = ENVIRONMENT BLOCK
        XOR SI,SI
COMSP_LOOP:
        LODSB
        AND AL,AL
        IF Z JMP NO_COMSPEC_ERROR
        MOV DI,COMSPEC
        DEC SI
COMPARE_VAR:
        MOV AH,CS:[DI]
        AND AH,AH
        JZ FOUND_COMSPEC
        LODSB
        CMP AL,AH
        JNZ FIND_NEXT
        INC DI
        JMP COMPARE_VAR
FIND_NEXT:
        AND AL,AL
        JZ COMSP_LOOP
        LODSB
        JMP FIND_NEXT
FOUND_COMSPEC:
        LODSB
        CMP AL,32
        JZ FOUND_COMSPEC
        CMP AL,'='
        JZ FOUND_COMSPEC
        DEC SI
        XOR AX,AX
        MOV ES,AX
        PUSH ES:[108]
        PUSH ES:[110]                   ;BEWAAR EIGEN CTRL-BREAK HANDLER
        PUSH SI
        PUSH DS
        CALL UNINSTALL_COM
        CALL GET_VECTORS                ;RESTORE CTRL-BREAK HANDLER
        call text_mode
        PUSH CS
        POP DS
        MOV DX,SHELLMES
        MOV AH,9
        INT 021
        MOV AH,048
        MOV BX,0FFFF
        INT 021
        ADD BX,32                       ;ADD .5 K
        MOV CL,6
        SHR BX,CL
        CMP BX,5
        IF A SUB BX,4
        MOV CL,0                        ;FLAG, LEADING ZERO SUPPRESSION
        MOV DX,1000
        CALL PRBX
        MOV DX,100
        CALL PRBX
        MOV DX,10
        CALL PRBX
        MOV DX,1
        MOV CL,1                        ;TRAILING ZERO
        CALL PRBX
        MOV DX,SHELLMES2
        MOV AH,9
        INT 021
        POP DS
        POP DX
        MOV BX,PAR_BLK
        PUSH CS
        POP ES
        MOV CS:SAVED_SS,SS
        MOV CS:SAVED_SP,SP
        MOV AX,04B00
        INT 021
        CLI
        MOV SS,CS:SAVED_SS
        MOV SP,CS:SAVED_SP
        STI
        MOV AX,0
        MOV ES,AX
        POP ES:[110]
        POP ES:[108]
        PUSHF                           ;BEWAAR EVT. CARRY
        CALL INIT_VIDEO                 ;ZET GRAFISCHE KAART WEER AAN
        call restore_ems
        mov ax,8
        push ax
        PUSH CS
        CALL _UPDATE_VIDEO              ;ZET SPECTRUM BEELD OP SCHERM
        pop ax
        POPF
        MOV AX,0
        IF C MOV AX,1                   ;1=ERROR GEDURENDE UITVOERING EXEC
        JMP SHORT RETURN_TO_C
NO_COMSPEC_ERROR:
        MOV AX,2
RETURN_TO_C:
        LEAV

PRBX:   MOV AH,'0'-1
PRBXL:  INC AH
        SUB BX,DX
        JAE PRBXL
        ADD BX,DX
        CMP AH,'0'
        JNZ NOZERO
        CMP CL,0
        JZ RET
NOZERO: INC CL
        MOV DL,2
        XCHG AH,DL
        INT 021
        RET

;
;int flushoutput(void)
;
_FLUSHOUTPUT:
        PUSH BP
        ENTR
        CALL FLUSHOUTPUT                ;IN Z80.8
        LEAV

;
;void clrinp(void)
;
_CLRINP:                                ;zie ook clearinput in misc.8
        MOV WORD CS:GETIN,OFFSET INBUF
        MOV WORD CS:PUTIN,OFFSET INBUF
        RETF

;
;void clroutp(void)
;
_CLROUTP:
        MOV WORD CS:GETOUT,OFFSET OUTBUF
        MOV WORD CS:PUTOUT,OFFSET OUTBUF
        RETF

;
;int inpakken(void)
;
_INPAKKEN:
        PUSH BP
        ENTR
        OR CS:B[RR_BIT7],32
        CALL SCRUNGE
        MOV AX,CX
        LEAV

DTA     DB 040 DUP ?

;
;int findfirst(attr,name,buf)
;char attr;
;char *name;
;unsigned char *buf;
;
;0xffff = fout
;
_FINDFIRST:
        PUSH BP
        MOV BP,SP

        STRC
ATTR    DW ?
NAAM2   DD ?
BUF     DD ?
        ENDS

        ENTR
        PUSH CS
        POP DS
        MOV DX,OFFSET DTA
        MOV AH,01A
        INT 021
        MOV AH,04E
        MOV CX,ATTR
        AND CX,0FF
        LDS DX,BUF
        PUSH DS
        PUSH DX
        LDS DX,NAAM2
        JMP SHORT FINDNEXT2

;
;int findnext(buf);
;unsigned char *buf;
;
;0xffff = fout
;
_FINDNEXT:
        PUSH BP
        MOV BP,SP

        STRC
BUFR    DD ?
        ENDS

        ENTR
        MOV AH,04F
        LDS DX,BUFR
        PUSH DS
        PUSH DX
FINDNEXT2:
        INT 021
        POP DI
        POP ES
        IF NC XOR AX,AX
        PUSH AX
        PUSH CS
        POP DS
        MOV SI,OFFSET DTA+015
        CLD
        MOVSB
        MOV SI,OFFSET DTA+01E
FINDNEXT3:
        LODSB
        STOSB
        CMP AL,0
        JNZ FINDNEXT3
        POP AX
        LEAV

tapname:        db "*.tap",0
;
;int findfirst_ra(unsigned char *dtabuf);
;
_findfirst_ra:
        push bp
        mov bp,sp

        strc
dtabuf  dd ?
        ends

        entr
        lds dx,dtabuf
        mov ah,01a
        int 021
        MOV AH,04E
        MOV CX,031              ;normal + subdir
        push cs
        pop ds
        mov dx,offset tapname
        jmp short findnext_2

;
;int findnext_ra(unsigned char *dtabuf);
;
_findnext_ra:
        push bp
        mov bp,sp

        strc
dtabuf2 dd ?
        ends

        entr
        lds dx,dtabuf2
        mov ah,04f
findnext_2:
        int 021
        mov ax,0
        jc findnext_end
        lds dx,dtabuf2
        add dx,01e
        MOV AX,2                ;r/w
        MOV AH,03D
        INT 021
        IF C MOV AX,0
findnext_end:
        leav


;
;int chdir(dir)
;char *dir;
;
_CHDIR:
        PUSH BP
        MOV BP,SP

        STRC
DIREC   DD ?
        ENDS

        ENTR
        MOV AH,019
        INT 021                         ;Get default drive in al
        PUSH AX                         ; and save it
        LDS DX,DIREC
        XOR AX,AX                       ;signal 'Ok'
        MOV BX,DX
        CMP B[BX],0
        JZ CHDIR_E                      ;No string: Ok
        CMP B[BX+1],':'
        JNZ NO_CHDRV                    ;Change default drive
        MOV DL,B[BX]
        AND DL,0DF                      ;upcase drive letter
        SUB DL,'A'                      ;0=A, 1=B etc
        push bx
        mov bl,dl
        inc bl
        mov ax,0440f
        int 021                         ;Bypass DOS message for logical drives
        pop bx
        MOV AH,0E
        INT 021
        MOV AH,019
        INT 021
        CMP DL,AL                       ;Successfully changed?
        MOV AX,-1                       ;Signal 'Error'
        JNE CHDIR_E
        MOV DX,BX
        ADD BX,2
        CMP B[BX],0                     ;Directory following drive letter?
        JNE NO_CHDRV                    ;If so, change default directory
        INC AX                          ;If not, change AX to 0 to signal
        JMP CHDIR_E                     ; success, and terminate.
NO_CHDRV:
        XOR AL,AL
        INC BX
CHDIR_LOOP:                             ;Strip trailing \ from directory
        CMP B[BX],0                     ; name, unless it is the 'root' \
        JZ CHDIR_END
        MOV AL,B[BX]
        INC BX
        JMP CHDIR_LOOP
CHDIR_END:
        CMP AL,'\'
        IF Z MOV B[BX-1],0
        MOV AH,03B                      ;Change directory
        INT 021
        SBB AX,AX
CHDIR_E:
        TEST AX
        POP DX                          ;Get previous cur. drive in dl
        JZ CHDIR_E2
        mov bl,dl
        inc bl
        mov ax,0440f
        int 021
        MOV AH,0E
        INT 021
        MOV AX,0FFFF
CHDIR_E2:
        LEAV

;
;void getdir(dir)
;char *dir;
;
_GETDIR:
        PUSH BP
        MOV BP,SP

        STRC
DIREC   DD ?
        ENDS

        ENTR
        MOV AH,019
        INT 021
        ADD AL,'A'
        LeS dI,DIREC
        cld
        STOSB
        MOV AL,':'
        STOSB
        MOV AL,'\'
        STOSB
        push es
        pop ds
        mov si,di
        MOV DL,0
        MOV AH,047
        INT 021
        cmp b[si],'\'
        if z mov b[si],0
        LEAV

;
;int hoesnel(void)
;
_hoesnel:
        shr byte cs:mflag,1
        MOV AL,b[offset _RR_EMUL]
        sub al,1
        cmc
        rcl byte cs:mflag,1
        call hoesnel
        retf


;
;void speed_convert(speed)
;char *speed;
;
_speed_convert:
        push bp
        mov bp,sp
        strc
speed   dd ?
        ends
        entr
        shr byte cs:mflag,1
        MOV AL,b[offset _RR_EMUL]
        sub al,1
        cmc
        rcl byte cs:mflag,1
        lds si,speed
        call haalpromille
        call speed_convert
        leav

;                               ;De inverse functie zit in Xtra.C en in
;void maakinstelbits(void)      ;Z80.8, bij de Call _Uitpakken
;
_maakinstelbits:
        mov al,byte _joymode
        shl al,1
        shl al,1
        or al,byte _syncmod
        shl al,1
        test byte _double,0ff
        if nz or al,1
        shl al,1
        test byte _issue2,0ff
        if nz or al,1
        shl al,1
        shl al,1
        and byte cs:imode,3
        or byte cs:imode,al
        retf


setupsaveload:
        xor ax,ax
        mov ds,ax
        cli
        mov word [36],keyboard
        mov [38],cs
        mov byte cs:keyscan,1
        sti
        in al,021
        push ax
        or al,1+8+16            ;alleen keyboard overhouden (geen timer, com1 of 2)
        out 021,al
        mov byte cs:modflg,1    ;voor de out-routine 'overscan'
        push cs
        pop es
        mov ds,cs:specseg
        pop ax
        ret

tcstgap dw ?
tcstgap0 dw ?
tcst1 dw ?
tcst2 dw ?
tcst3 dw ?
tcst4 dw ?
tcst5 dw ?
tcst6 dw ?

;
;int saveblock(void)
;
_saveblock:
        push bp
        entr
        call setupsaveload
        push ax
        mov ax,cs:cxloop
        push ax
;
;Met de waarde CXLOOP in CX is een pauze te krijgen van 1/16 van een
;timertik, dwz 1/(18.2 x 16) s. 1 T state (1/3.5 MHz) duurt CXLOOP/12019.2
;passages.
;
        mov dx,11821
        mul dx
        mov cs:tcst1,dx       ;2168 T states
        pop ax
        push ax
        mov dx,3637
        mul dx
        mov cs:tcst2,dx       ;667 T states
        pop ax
        push ax
        mov dx,4008
        mul dx
        mov cs:tcst3,dx       ;735 T states
        pop ax
        mov dx,4662
        mul dx
        mov cs:tcst4,dx       ;855 T states
        or byte cs:[offset rfa+1],65             ;cy + z: OK, nobreak
timing macro
        cmp byte cs:gmod,4      ;EGA mode? (dwz overscan bij OUT)
        if ae sub cx,7          ;zo ja, verminder CX
        sub cx,#1+9             ;OUT+timing ongeveer 9x NOP/LOOP
#em
        mov ah,2
sa_leader:
        mov cx,cs:tcst1
        timing 2
        NOP
        nop
        nop
        ORG (($-kr25) AND 0FFFC)
sa_leader2:
        nop
        loop sa_leader2
        call far overscan
        test byte cs:keyscan,2
        if nz jmp returnsaveload
        xor ah,0f
        dec word cs:rhl
        jne sa_leader
        mov cx,cs:tcst2
        timing 2
        NOP
        nop
        nop
        ORG (($-kr25) AND 0FFFC)
sa_sync_1:
        nop
        loop sa_sync_1
        call far overscan
        mov ah,0d
        mov cx,cs:tcst3
        timing 1
        NOP
        nop
        nop
        ORG (($-kr25) AND 0FFFC)
sa_sync_2:
        nop
        loop sa_sync_2
        call far overscan
        mov cx,cs:tcst4
        timing 5
        mov al,byte cs:rafa     ;haal flag byte
        mov ah,al
        or cs:byte keyscan,8
        jmp short sa_start
sa_loop:
        test word cs:rde
        jz sa_parity
        mov bx,cs:rix
        mov al,[bx]
sa_loop_p:
        mov ah,dh
        xor ah,al
sa_start:
        mov dh,ah
        mov ah,1
        stc
        jmp short sa_8bits
sa_parity:
        mov al,dh
        jmp short sa_loop_p
sa_bit_2:
        popf
        mov ah,08e
        NOP
        nop
        nop
        ORG (($-kr25) AND 0FFFC)
sa_bit_1:
        nop
        loop sa_bit_1
        pushf
        jnc sa_out
        mov cx,cs:tcst4
        dec cx
        NOP
        nop
        nop
        ORG (($-kr25) AND 0FFFC)
sa_set: nop
        loop sa_set
sa_out: call far overscan
        mov cx,cs:tcst4
        timing 3
        test ah,080
        je sa_bit_2
        popf
        mov ah,1
        sub cx,3
        clc
sa_8bits:
        rcl al,1
        rcl ah,1
        test al,al
        je sa_bit_end
        rcr ah,1
        jmp sa_bit_1
sa_bit_end:
        dec word cs:rde
        inc word cs:rix
        test byte cs:keyscan,2
        jnz returnsaveload
        mov cx,cs:tcst4
        timing 11
        cmp cs:byte[offset rde+1],0ff
        if ne jmp sa_loop
        mov cx,cs:tcst4
        timing 0
sa_delay:
        nop
        loop sa_delay
returnsaveload:
        mov cs:rpc,05e2
        call get_vectors
        mov byte cs:modflg,0
        pop ax
        out 021,al
        mov al,byte cs:keyscan
        and al,12
        cmp al,4
        jz opf7gedrukt
        xor ax,ax
        test byte cs:keyscan,2
        jz opf7gedrukt
        and byte cs:[offset rfa+1],0be          ;nc/nz: break (they're set above)
        mov byte cs:spctel,5                    ;and press space for .1 second
opf7gedrukt:
        mov byte cs:keyscan,0
        leav

;
;int loadblock(void)
;
_loadblock:
        push bp
        entr
        call setupsaveload
        push ax
;
;De waarde in INLOOP staat voor 1/(18.2 x 4) s. 1 T state komt overeen
;met INLOOP/48077
;
        mov ax,cs:inloop
        mov bx,ax
        mov dx,5540
        mul dx
        mov cs:tcst1,dx       ;6500-2436 = 4065 T
        mov ax,bx
        mov dx,8860
        mul dx
        mov cs:tcst2,dx       ;6500 T
        mov ax,bx
        mov dx,4982
        mul dx
        mov cs:tcst3,dx       ;3655 T
        mov ax,bx
        mov dx,870
        mul dx
        mov ax,cs:tcst3
        sub ax,dx
        mov cs:tcst4,ax       ;3655-638 T
        mov ax,bx
        mov dx,7593
        mul dx
        mov cs:tcst5,dx       ;5570 T
        mov ax,bx
        mov dx,5458
        mul dx
        mov cs:tcst6,dx       ;5570 - 1566 = 4004 T
        mov ax,cs:cxloop
        mov dx,2535
        mul dx
        mov cs:tcstgap,dx       ;465 T
        mov ah,0f
        call far overscan
        mov dx,cs:tapeio
        in al,dx
        and al,080
        or al,2
        mov bl,al
        cmp al,al
ldbreak:
        if nz jmp load_retnc_borred
ldstart:
        mov cx,cs:inloop
        call ldedge1
        jnc ldbreak
        xor bh,bh
ldwait: mov cx,cs:cxloop
        shr cx,1
        NOP
        nop
        nop
        ORG (($-kr25) AND 0FFFC)
ldw2:   nop
        loop ldw2
        dec bh
        jne ldwait
        mov cx,cs:inloop
        call ldedge2
        jnc ldbreak
ldleader:
        mov cx,cs:tcst2       ;6500 T
        call ldedge2
        jnc ldbreak
        cmp cx,cs:tcst1       ;3000 T
        ja ldstart
        inc bh
        jne ldleader
ldsync: mov cx,cs:tcst3       ;3655 T
        call ldedge1
        jnc ldbreak
        cmp cx,cs:tcst4
        jb ldsync
        call ldedge1
        if nc jmp load_retnc
        or cs:byte keyscan,8
        xor bl,3
        xor bh,bh
        mov cx,cs:tcst5
        jmp short ldmarker
ldloop: mov al,cs:[offset rafa+1]
        mov cx,cs:tcst5
        dec cx
        dec cx
        test al,040
        jz ldflag               ;F' = NZ
        test al,1
        jz ldverify             ;F' = NC
        mov dx,bx
        mov bx,cs:rix
        cmp bx,04000
        jb ld_inrom
        mov b[bx],ah
ld_inrom:
        mov bx,dx
        jmp short ldnext
ldflag:
        mov al,cs:[offset rafa]
        xor al,ah
        if nz jmp load_retnc
        or byte cs:[offset rafa+1],040
        jmp short ldcontinue
ldverify:
        mov dx,bx
        mov bx,cs:rix
        xor ah,es:b[bx]
        jne load_retnc
        mov bx,dx
ldnext: inc word cs:rix
        dec word cs:rde
ldcontinue:
ldmarker:
        mov ah,1
ld8bits:
        call ldedge2
        jnc load_retnc
        cmp cx,cs:tcst6
        rcl ah,1
        mov cx,cs:tcst5
        jnc ld8bits
        xor bh,ah
        cmp cs:rde,0
        if ne jmp ldloop
        or byte cs:[offset rfa+1],65
        cmp bh,0
        je >l1
load_retnc:
        and byte cs:[offset rfa+1],0fe
l1:     mov byte cs:rfa,bh
        mov bl,ah
        mov word cs:rhl,bx
        mov word cs:rbc,0cb01
        jmp returnsaveload              ;this sets the flags in case of BREAK
load_retnc_borred:
        and byte cs:[offset rfa+1],0fe  ;exit point for BREAK or F6 in leader
        jmp returnsaveload


ldedge2:
        call ldedge1
        jnc ret
ldedge1:
        push cx
        mov cx,cs:tcstgap
        sub cx,17
        NOP
        nop
        nop
        ORG (($-kr25) AND 0FFFC)
lddelay:
        nop
        loop lddelay
        pop cx
        mov dx,cs:tapeio
        NOP
        nop
        nop
        ORG (($-kr25) AND 0FFFC)
ldsample:
        test cs:keyscan,2
        jnz ret                 ;ZF=0, CF=0 als key pressed
        in al,dx
        xor al,bl
        add al,al
        jc ldedge
        loop ldsample
        cmp al,al
        ret                     ;ZF=1, CF=0 als time up
ldedge:
        not bl
        xchg ah,al
        mov ah,bl
        and ah,7
        or ah,8
        push bx
        call far overscan
        pop bx
        xchg ah,al
        cmp byte cs:gmod,4
        jb nodelay
        push cx
        mov cx,5
        NOP
        nop
        nop
        ORG (($-kr25) AND 0FFFC)
edge_delay:
        nop
        loop edge_delay
        pop cx
nodelay:
        stc
        ret                     ;CF=1 als ok


;
;void getissue2default(tapeaddress)
;int tapeaddress
;
_getissue2default:
        PUSH BP
        MOV BP,SP

        STRC
tapeaddress  DW ?
        ENDS

        ENTR
        mov dx,tapeaddress
        in al,dx
        shr al,1
        and al,040
        mov cs:issue2default,al
        leav


;
;int testfordrive(drive)
;int drive;
;
_testfordrive:
        push bp
        mov bp,sp

        strc
drive   dw ?
        ends

        mov ah,019              ;get current default drive
        int 021
        push ax
        mov dx,drive
        mov ah,0e
        int 021                 ;try to make default drive DRIVE
        mov ah,019
        int 021                 ;get current default drive
        xor ah,ah
        cmp ax,drive            ;these are equal if the drive exists
        mov ax,0
        if z dec ax             ;0 = error
        pop dx
        push ax
        mov ah,0e
        int 021                 ;restore default drive.
        pop ax
        pop bp
        retf                    ;ax=0 if there is no drive DRIVE

close_tapefiles:
        push ds
        mov ds,seg _firsttime
        mov al,_firsttime
        test al,al
        jnz nothingtoclose
        mov bx,_tapeouth
        mov ah,03e
        test bx,bx
        if nz int 021
        mov bx,_tapeinh
        mov ah,03e
        test bx,bx
        if nz int 021
nothingtoclose:
        pop ds
        ret

;
;savediskblock(start,length,afpair,tapeouth,extrabytes,chksm);
;unsigned int start,length,afpair;
;int tapeouth;
;
_savediskblock:
        push bp
        mov bp,sp

        strc
sstart   dw ?
slength  dw ?
safpair  dw ?
stapeh   dw ?
sebytes  dw ?
schksm   dw ?
        ends

        entr
        or byte cs:[offset rfa+1],65             ;cy + z: OK, nobreak
        mov ds,cs:specseg
        mov ax,slength
        mov si,ax
        cmp ah,0ff
        if z mov ax,0
        add ax,sebytes                  ;Allow for flag & checksum
        mov di,ax                       ;Shouldn't push here
        mov bx,stapeh
        call savebyte
        mov al,ah
        call savebyte
        mov ax,di
        test ax
        jz leave_sdb
        mov ax,safpair
        call savebyte
        mov dx,sstart
        mov cx,si
        xor ax,ax
        add cx,dx
        if c xor cx,cx                  ;Mind the segment boundary
        sub cx,dx
        mov ah,040
        int 021
        jc sdb_diskerr
        cmp ax,cx
        jnz sdb_diskerr
        xor dx,dx
        mov cx,si
        sub cx,ax
        mov ah,040
        if nz int 021
        push bx
        mov bx,sstart
        mov cx,si
        mov ax,safpair
        jcxz sdb_finished
sdb_checksum:
        xor al,[bx]
        inc bx
        loop sdb_checksum
sdb_finished:
        pop bx
        xor ax,schksm
        cmp sebytes,2
        if z call savebyte
        xor ax,ax
leave_sdb:
        leav
sdb_diskerr0:
        pop ax
sdb_diskerr:
        mov ax,2
        leav
savebyte:
        xchg al,[0]                     ;Store at 0000 in ROM
        push ax                         ; (nice workspace)
        xor dx,dx
        mov cx,1
        mov ah,040
        int 021
        pop dx
        xchg dl,[0]
        jc sdb_diskerr0
        cmp ax,cx
        jnz sdb_diskerr0
        mov ax,dx
        ret

blocklength     dw ?
actlen          dw ?
bufpos          dw ?
bufmax          dw ?
filepos1        dw ?
filepos2        dw ?
;
;loaddiskblock(start,length,tapeinh);
;unsigned int start,length;
;int tapeinh;
;
_loaddiskblock:
        push bp
        mov bp,sp

        strc
lstart   dw ?
llength  dw ?
ltapeh   dw ?
        ends

        entr
        push ds
        pop es
        push cs
        pop ds
        mov dx,offset blocklength
        mov bx,ltapeh
        mov cx,2
        mov ah,03f
        int 021
        if c jmp ldb_err
        test ax,ax
        if z jmp ldb_eof
        cmp ax,2
        if nz jmp ldb_err
        mov ax,blocklength
        mov actlen,ax
        mov bufpos,0
        mov bufmax,0
        xor cx,cx
        xor dx,dx
        mov ax,04201
        int 021
        if c jmp ldb_err
        mov filepos1,dx
        mov filepos2,ax
        mov ds,specseg
        xor bh,bh
        jmp lddcontinue
lddloop: mov dl,ah
        mov ax,cs:rafa
        sahf
        mov ah,dl
        jnz lddflag               ;F' = NZ
        jnc lddverify             ;F' = NC
        mov dx,bx
        mov bx,cs:rix
        cmp bx,04000
        if ae mov b[bx],ah
        mov bx,dx
        jmp short lddnext
lddflag:
        mov al,cs:[offset rafa]
        xor al,ah
        if nz jmp loaddisk_retnc
        or byte cs:[offset rafa+1],040
        jmp short lddcontinue
lddverify:
        mov dx,bx
        mov bx,cs:rix
        xor ah,b[bx]
        jne loaddisk_retnc
        mov bx,dx
lddnext: inc word cs:rix
        dec word cs:rde
lddcontinue:
        call loadbyte
        jc loaddisk_retnc
        xor bh,ah
        cmp cs:rde,0                    ;Note: this will cause a tape loading
        jne lddloop                     ; error when loading a 0 byte block.
        or byte cs:[offset rfa+1],65
        cmp bh,0
        jne loaddisk_retnc
        jmp short loaddisk_return
loaddisk_retnc:
        and byte cs:[offset rfa+1],0fe
loaddisk_return:
        mov byte cs:rfa,bh
        mov word cs:rbc,0cb01
        mov bl,ah
        mov word cs:rhl,bx
        mov word cs:rpc,05e2
        mov cx,cs:filepos1
        mov dx,cs:filepos2
        mov ax,04200
        mov bx,ltapeh
        int 021
        jc ldb_err
        mov dx,cs:blocklength
        xor cx,cx
        mov ax,04201
        int 021
        mov ax,0
        adc ax,0
        leav
ldb_err:
        mov ax,2
ldb_return:
        and byte cs:[offset rfa+1],0fe
        mov word cs:rpc,05e2
        leav
ldb_eof:
        mov ax,1
        jmp ldb_return

loadbyte:
        push bx
        push cx
        push ds
        lds bx,es:_buffer
loadblockbyte:
        mov ax,cs:bufpos
        cmp ax,cs:bufmax
        jae loadnextblock
        add bx,ax
        mov ah,[bx]
        inc word cs:bufpos
loadblockret:
        pop ds
        pop cx
        pop bx
        clc
        ret
loadnextblock:
        mov ax,cs:actlen
        test ax,ax
        jz loadblockerr
        mov cs:bufpos,0
        push dx
        push bx
        mov cx,ax
        cmp ax,16000
        if a mov cx,16000
        sub ax,cx
        mov cs:actlen,ax
        mov cs:bufmax,cx
        mov dx,bx
        mov ah,03f
        mov bx,ltapeh
        int 021
        pop bx
        pop dx
        jc loadblockerr
        cmp ax,cx
        jz loadblockbyte
loadblockerr:
        mov cs:actlen,0
        mov cs:bufmax,0
        pop ds
        pop cx
        pop bx
        stc
        ret

;
;unsigned int memalloc(int)
;
_memalloc:
        push bp
        mov bp,sp

        strc
pars    dw ?
        ends

        entr
        mov bx,pars
        mov ah,048
        int 021
        if c xor ax,ax
        leav

;
;int lseek(int,unsigned int*,unsigned int*,char)
;
_lseek:
        push bp
        mov bp,sp

        strc
lshandle dw ?
positionlo dd ?
positionhi dd ?
mode db ?
        ends

        entr
        les bx,positionlo
        mov dx,es:[bx]
        les bx,positionhi
        mov cx,es:[bx]
        mov bx,lshandle
        mov ah,042
        mov al,mode
        int 021
        les bx,positionlo
        mov es:[bx],ax
        les bx,positionhi
        mov es:[bx],dx
        sbb ax,ax
        leav

GET_C_VARS:
        MOV AX,SEG _DOUBLE
        MOV DS,AX
        MOV AL,CS:OUTMODE
        MOV _OUTMODE,AL
        MOV AX,CS:OUTNUM
        MOV _OUTNUM,AX
        MOV AL,CS:INMODE
        MOV _INMODE,AL
        MOV AX,CS:INNUM
        MOV _INNUM,AX
        MOV AL,CS:SILENCE
        MOV _SILENCE,AL
        mov al,cs:winkey
        mov _winkey,al
        MOV AL,CS:DOUBLE
        MOV OFFSET _DOUBLE,AL
        MOV AL,CS:FLASH
        MOV _FLASH,AL
        mov ah,cs:mflag
        shr ah,1
        sbb al,al
        MOV _RR_EMUL,AL
        shr ah,1
        sbb al,al
        MOV _LDRFLAG,AL
        MOV AL,CS:GMOD
        MOV _GMOD,AL
        MOV AL,CS:JOYMODE
        MOV _JOYMODE,AL
        MOV AL,CS:REGIST
        MOV _REGIST,AL
        MOV AL,CS:ISSUE2
        MOV _ISSUE2,AL
        MOV AL,CS:SYNCMOD
        MOV _SYNCMOD,AL
        MOV AX,CS:RSCOUNT
        MOV _RSCOUNT,AX
        MOV AX,CS:RSOUTCOUNT
        MOV _RSOUTCOUNT,AX
        MOV AL,CS:MODFLG
        MOV _MODFLG,AL
        MOV AL,CS:TAPEIF
        MOV _TAPEIF,AL
        MOV AX,CS:TAPEIO
        MOV _TAPEIO,AX
        mov al,cs:b[ramstate]
        mov _romstate,al
        MOV BYTE CS:KEMPSTON_STATE,0
        MOV AX,CS:SPECSEG
        MOV WORD _SPECPOINTER,0
        MOV [OFFSET _SPECPOINTER+2],AX
        MOV WORD _REGPOINTER,OFFSET RFA
        MOV [OFFSET _REGPOINTER+2],CS
        MOV AX,CS:PROGSEG
        MOV W[OFFSET _PROG],0
        MOV W[OFFSET _PROG+2],AX
        mov al,cs:rommod
        mov _rommod,al
        mov cx,16
        xor bx,bx                       ;8 mhandles (word) + 8 writprot (byte)
gcv_transfer:
        mov al,cs:[bx+offset mhandles]
        mov [bx+offset _mhandles],al
        inc bx
        loop gcv_transfer
        xor bx,bx
        mov cx,8
gcv_t2: mov al,cs:[bx+offset writprot]
        mov [bx+offset _writprot],al
        inc bx
        loop gcv_t2
        CALL RS_READ_READY              ;C=EOF
        SBB AL,AL
        MOV _EOFIL,AL
        RET

SAVE_C_VARS:
        MOV AX,SEG _DOUBLE
        MOV DS,AX
        MOV AL,_SILENCE
        MOV AH,B[OFFSET _DOUBLE]
        MOV BH,_FLASH
        MOV DL,_GMOD
        MOV CS:SILENCE,AL
        MOV CS:OFFSET DOUBLE,AH
        MOV CS:FLASH,BH
        MOV CS:GMOD,DL
        xor ah,ah
        mov al,_ldrflag
        sub al,1
        cmc
        rcl ah,1
        mov al,_rr_emul
        sub al,1
        cmc
        rcl ah,1
        mov cs:mflag,ah
        MOV AL,_OUTMODE
        MOV CS:OUTMODE,AL
        MOV AL,_INMODE
        MOV CS:INMODE,AL
        MOV AX,_OUTNUM
        MOV CS:OUTNUM,AX
        MOV AX,_INNUM
        MOV CS:INNUM,AX
        MOV AL,_JOYMODE
        MOV CS:JOYMODE,AL
        MOV AL,_ISSUE2
        MOV CS:ISSUE2,AL
        MOV AL,_SYNCMOD
        MOV CS:SYNCMOD,AL
        MOV AX,_RSCOUNT
        MOV CS:RSCOUNT,AX
        MOV AX,_RSOUTCOUNT
        MOV CS:RSOUTCOUNT,AX
        MOV AL,_MODFLG
        MOV CS:MODFLG,AL
        MOV AL,_TAPEIF
        MOV CS:TAPEIF,AL
        MOV AX,_TAPEIO
        MOV CS:TAPEIO,AX
        mov al,_winkey
        mov cs:winkey,al
        MOV AL,b[offset _IMMNMI]
        MOV CS:IMMNMI,AL
        mov al,_rommod
        mov cs:rommod,al
        mov cx,16
        xor bx,bx                       ;8 mhandles (word) + 8 writprot (byte)
scv_transfer:
        mov al,[bx+offset _mhandles]
        mov cs:[bx+offset mhandles],al
        inc bx
        loop scv_transfer
        xor bx,bx
        mov cx,8
scv_t2: mov al,[bx+offset _writprot]
        mov cs:[bx+offset writprot],al
        inc bx
        loop scv_t2
        RET

;
;void flush_mdrv_buffer(void)
;
_flush_mdrv_buffer:
        push bp
        entr
        call mdrv_clearbuffer
        leav

;
;void press_break(void)
;
_press_break:
        mov byte cs:spctel,5
        and byte cs:[offset in_tab+7],0fe
        retf

;
;void mdrv_reset(void)
;
_mdrv_reset:
        call mdrv_clearbuffer
        retf

;
;int load_z80_file(int type,int handle)
;
_load_z80_file:
        push bp
        mov bp,sp

        strc
typel   dw ?
handlel dw ?
        ends

        entr
        call save_c_vars
        mov ax,typel
        mov bx,handlel
        call load_z80_file
        push ax
        IN AL,061
        AND AL,011111100XB
        OUT 061,AL                      ;EVT PIEP UIT
        call get_c_vars
        pop ax
        leav

;
;int save_z80_file(int handle)
;
_save_z80_file:
        push bp
        mov bp,sp

        strc
handlew dw ?
        ends

        entr
        call save_c_vars
        mov bx,handlew
        call save_z80_file
        push ax
        call get_c_vars
        pop ax
        leav

;
;void init_emulmode(int emod,int reset)
;
;This routine tries to change the emulated computer (48,samram,128)
;while keeping as much information intact in memory as possible.
;If only if1 is switched on or off, it does nothing.
;If samram is switched to 48k or vv, the ram pages are set in the
;default state (int. 8,4,5) and the also the default rom is selected.
;If the 128K is switched to sam of 48k, it is assumed the 128 is in
;48 mode. Page layout: 2nd 128 rom;page 5;page 2;page 0. Internal
;pages resp. 2,8,5,3. So page 2 is copied to page 4, and 3 to 5.
;If 48 is switched to 128, then, if no reset, the reverse is done, and
;the second rom is activated. If the 128 is to be reset, then the first
;rom is paged.
;
_init_emulmode:
        push bp
        mov bp,sp

        strc
emod    dw ?
reset   dw ?
        ends

        entr
        mov ax,emod
        cmp al,2
        if a inc al                     ;0,1,2,4,5
        mov ah,cs:rommod
        cmp ah,2
        if a inc ah                     ;0,1,2,4,5
        and ax,0606
        cmp al,ah
        if z jmp iem_nochange           ;if only if1 switched on/off, nochange
        mov byte cs:if1flg,0            ;if1 rom not paged
        cmp al,2
        if be jmp iem_to48k
        mov ax,0108                     ;copy page 4/5 (norm) to page 5/3 (128)
        call swap_mem
        mov ax,0303
        call swap_mem
        mov ax,0205
        call swap_mem
        push ds
        mov ax,cs:specseg
        mov ds,ax
        mov es,ax
        mov si,08000
        mov di,0c000
        mov cx,02000
        cld
        rep movsw                       ;copy page 5 to page 3
        mov ax,0304
        call swap_mem
        mov si,0c000
        mov di,08000
        mov cx,02000
        rep movsw                       ;copy page 4 to page 5
        pop ds
        mov ax,0303                     ;Now page layout is: 8/5/3
        call swap_mem
        mov ax,emod
        mov cs:rommod,al
        call load_romfile
        mov cs:b[offset sstate+7],0ff   ;turn off all sound channels
        cmp reset,0
        jnz iem_128_reset
        mov byte cs:hstate,030          ;value of port 7ffd when in 128's 48k mode
        mov ax,0                        ;normal 128 rom
        call swap_mem
        leav
iem_128_reset:
        mov byte cs:hstate,0            ;store page layout
        mov word cs:rpc,0                    ;and reset
        mov ax,2
        call swap_mem
        leav
iem_nochange:
        mov ax,emod
        cmp cs:rommod,al
        mov cs:rommod,al
        jz iem_same
        push cs
        pop es                          ;for pagin_n_rom_far
        cmp byte cs:if1flg,0            ;if1 rom paged?
        if nz call far pagin_n_rom_far
        mov al,0ff
        cmp byte cs:rommod,0            ;mode: norm (no if1)
        if z xor al,al
        cmp byte cs:rommod,3            ;mode: 128 (no if1)
        if z xor al,al
        mov byte cs:if1_on,al
        cmp reset,0
        jz iem_same
        mov word cs:rpc,0
        mov ax,2
        cmp cs:rommod,2
        if b xor al,al
        call swap_mem
        mov ax,0108
        call swap_mem
        mov ax,0205
        cmp cs:rommod,2
        if be mov al,4
        call swap_mem
        mov ax,0303
        cmp cs:rommod,2
        if be mov al,5
        call swap_mem
        mov byte cs:hstate,0
        mov bx,offset in31tab
        mov cx,8
l1:     mov cs:b[bx],0
        inc bx
        loop l1
iem_same:
        leav
iem_to48k:
        push ax
        push cs
        pop es                          ;for pagin_n_rom_far
        cmp byte cs:if1flg,0            ;if1 rom paged?
        if nz call far pagin_n_rom_far
        pop ax
        cmp ah,2
        jbe iem_to48k_from48k
        push ds
        mov al,cs:b[offset ramstate+3]
        push ax
        mov ax,0205
        call swap_mem
        mov ax,0304
        call swap_mem
        mov ax,cs:specseg
        mov ds,ax
        mov es,ax
        mov si,08000
        mov di,0c000
        cld
        mov cx,02000
        rep movsw                       ;copy page 5 to page 4
        pop ax
        cmp al,5
        je dont_copy
        mov ah,3
        call swap_mem
        mov si,0c000
        mov di,08000
        mov cx,02000
dont_copy:
        rep movsw                       ;copy page [3] to page 5
        pop ds                          ;(works only if [3]<>4)
iem_to48k_from48k:
        mov ax,0108                     ;page layout for samram in basic and
        call swap_mem                   ;normal spectrum
        mov ax,0204
        call swap_mem
        mov ax,0307                     ;shadow ram
        call swap_mem
        mov ds,cs:specseg
        mov b[0ffff],0                  ;to signal 'nmi software not active'
        mov ax,0305
        call swap_mem
        mov bx,offset in31tab
        mov cx,8
iem_48_in31:
        mov cs:b[bx],0                  ;Reset 74ls259
        inc bx
        loop iem_48_in31
        mov ax,emod
        mov cs:rommod,al
        call load_romfile
        cmp cs:rommod,2
        mov ax,0
        if z mov al,2
        call swap_mem
        cmp reset,0
        if nz mov word cs:rpc,0
        leav

;
;void set_nmireset(char)
;
_set_nmireset:
        push bp
        mov bp,sp

        strc
nmireset dw ?
        ends

        mov ax,nmireset                 ;0x80 or 0xff; see kr24
        dec al
        MOV byte CS:NMI,al
        and cs:b[in2_tab+7],0fd         ;to let samram think symshift is up
        cmp word cs:trapadr,offset emulate
        if z mov word cs:trapadr,offset irupt        ;segment already OK
weird_address:
        pop bp
        retf

;
;void select_page5(void)
;
_select_page5:
        cmp byte cs:rommod,3
        jb >l1
        test byte cs:hstate,8
        je >l1
        mov ax,0304
        call swap_mem                   ;swap rampage 1 into bank 3
        mov ax,010a
        call swap_mem                   ;swap rampage 7 (screen) into bank 1
l1:     retf

;
;void reset_page5(void)
;
_reset_page5:
        mov ax,0108
        call swap_mem
        mov ah,cs:hstate
        mov al,ah
        xor al,7
        and al,31
        mov cs:hstate,al
        push cs
        pop es
        call far out_128_banksw
        retf

;
;int commit(int handle)
;
_commit:
        push bp
        mov bp,sp

        strc
chandle dw ?
        ends

        entr
        mov bx,chandle
        mov ah,045
        int 021                 ;dup
        mov bx,ax
        mov ah,03e
        int 021                 ;and close
        if nc xor ax,ax
        leav


;
;void clearkeyboard(void)
;
_clearkeyboard:
        MOV BYTE CS:LASTKEY,0
        MOV BX,OFFSET IN_TAB
        MOV CX,8
CLKT21: MOV CS:B[BX],255
        INC BX
        LOOP CLKT21
        MOV CL,8
CLKT22: MOV CS:B[BX],0
        INC BX
        LOOP CLKT22
        MOV BX,OFFSET SHFTSTATES
        MOV CX,35
CLSFTS: MOV CS:B[BX],0
        INC BX
        LOOP CLSFTS
        retf

;
;int spacebar(void)
;
_spacebar:
        mov al,cs:b[offset in_tab+7]
        not al
        and ax,1
        retf

;
;void delete_tapblock(int handle)
;
_delete_tapblock:
        push bp
        mov bp,sp

        strc
dhandl  dw ?
        ends

        entr
        push ds
        pop es
        mov bx,dhandl
        mov ah,03f
        lds dx,es:_buffer
        mov cx,2
        int 021
        jc del_finished
        cmp ax,2
        jnz del_finished
        xchg bx,dx
        mov ax,w[bx]
        add ax,2                ;ax=length of block to be deleted
        push ax
        xchg bx,dx
        mov cx,-1
        mov dx,-2
        mov ax,04201
        int 021
        mov di,dx
        mov si,ax
        pop dx
        xor cx,cx
        mov ax,04201
        int 021
del_block:
        lds dx,es:_buffer
        mov cx,16384
        mov ah,03f
        int 021
        if c xor ax,ax
        push ax
        xor cx,cx
        xor dx,dx
        mov ax,04201
        int 021
        xchg dx,di
        xchg ax,si
        xchg dx,ax
        xchg ax,cx
        mov ax,04200
        int 021
        lds dx,es:_buffer
        pop cx
        mov ah,040
        int 021
        if c xor ax,ax
        cmp ax,16384
        jne del_finished
        xor cx,cx
        xor dx,dx
        mov ax,04201
        int 021
        xchg dx,di
        xchg ax,si
        xchg dx,ax
        xchg ax,cx
        mov ax,04200
        int 021
        jmp del_block
del_finished:
        xor cx,cx
        mov ah,040
        int 021
        leav


startup ends
